# ğŸ§  ä¸€ã€å®Œæ•´ä½“ç³» vs çœŸå®å¯è½åœ°éƒ¨åˆ†

æˆ‘ä»¬åˆšæ‰æ„å»ºçš„æ˜¯ï¼š

```
UI â†’ æ—¥å¿— â†’ è§‚æµ‹ â†’ è¿½è¸ª â†’ å›¾è°± â†’ AI â†’ é¢„æµ‹ â†’ è‡ªæ²» â†’ ç¾¤ä½“æ™ºèƒ½
```

ä½†ç°å®é¡¹ç›®æˆåŠŸæ‰€éœ€çš„æ˜¯ï¼š

```
ğŸ¯ å¯è§‚æµ‹æ ¸å¿ƒé—­ç¯ï¼ˆé»„é‡‘ 20%ï¼‰
```

---

# ğŸ¥‡ äºŒã€çœŸæ­£å€¼å¾—å®ç°çš„â€œé»„é‡‘èƒ½åŠ›å±‚â€

åªä¿ç•™è¿™ **4 å±‚**ï¼š

| å±‚çº§                   | å¿…é¡»åš | åŸå›        |
| -------------------- | --- | -------- |
| **â‘  å®æ—¶æ—¥å¿— + çŠ¶æ€é©±åŠ¨ UI** | âœ…   | æ‰€æœ‰ç³»ç»ŸåŸºç¡€   |
| **â‘¡ å¤šæµè§‚æµ‹ + è¿‡æ»¤æœç´¢**    | âœ…   | è¿ç»´æ ¸å¿ƒéœ€æ±‚   |
| **â‘¢ æ—¶é—´è½´å›æ”¾ï¼ˆè°ƒè¯•æ¨¡å¼ï¼‰**    | âœ…   | äº‹æ•…æ’æŸ¥ç¥å™¨   |
| **â‘£ ç®€å•å¼‚å¸¸æ£€æµ‹ï¼ˆé AIï¼‰**   | âœ…   | 80% å‘Šè­¦åœºæ™¯ |

---

# âŒ ä¸‰ã€æš‚æ—¶ä¸è¦åšçš„éƒ¨åˆ†ï¼ˆæ€§ä»·æ¯”ä½ï¼‰

| èƒ½åŠ›      | ä¸ºä»€ä¹ˆå…ˆåˆ«åš      |
| ------- | ----------- |
| å¤æ‚æœºå™¨å­¦ä¹   | æ•°æ®ä¸è¶³ + è¯¯æŠ¥ç‡é«˜ |
| é¢„æµ‹å¼•æ“    | è¿ç»´ä¿¡ä»»åº¦ä½      |
| è‡ªæ²»æ‰§è¡Œ    | é£é™©æé«˜        |
| ç¾¤ä½“ååŒ AI | è¶…å¤§è§„æ¨¡æ‰æœ‰æ„ä¹‰    |

è¿™äº›æ˜¯**ç ”ç©¶çº§èƒ½åŠ›**ï¼Œä¸æ˜¯ MVP çº§ã€‚

---

# ğŸ§± å››ã€ç°å®å·¥ç¨‹æœ€ä¼˜æ¶æ„ï¼ˆç»ˆç«¯è§‚æµ‹ç³»ç»Ÿï¼‰

```
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  State     â”‚
                 â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚             â”‚             â”‚
     Log Stream    Metrics Poll   Event Input
         â”‚             â”‚             â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–¼           â–¼
           Virtual LogView   Timeline Mode
                 â”‚
             Diff Renderer
```

è¿™å¥—ç»“æ„ï¼š

* ç®€å•
* ç¨³å®š
* å¯æ‰©å±•
* æ€§èƒ½é«˜

---

# ğŸš€ äº”ã€ç”¨è¿™ 20% å¯ä»¥åšå‡ºä»€ä¹ˆçº§åˆ«ç³»ç»Ÿï¼Ÿ

| åœºæ™¯       | å®Œå…¨èƒœä»» |
| -------- | ---- |
| å¾®æœåŠ¡æ—¥å¿—ä¸­å¿ƒ  | âœ”    |
| SAP æ¥å£ç›‘æ§ | âœ”    |
| æ‰¹å¤„ç†ç›‘æ§å°   | âœ”    |
| å®æ—¶å‘Šè­¦å°    | âœ”    |
| è°ƒè¯•è¿½è¸ªå·¥å…·   | âœ”    |

ä½ å·²ç»èƒ½åš **ç”Ÿäº§çº§ç³»ç»Ÿ**ã€‚

---

# ğŸ§  å…­ã€ä¸ºä»€ä¹ˆè¿™æ˜¯â€œæœ€ä½³å·¥ç¨‹åˆ‡ç‰‡â€

è¿™ 20% è¦†ç›–äº†ï¼š

```
80% é—®é¢˜å®šä½
80% è¿ç»´åœºæ™¯
80% ç³»ç»Ÿå¯è§æ€§
```

ä½†å¤æ‚åº¦åªæœ‰åŸä½“ç³»çš„ 15%ã€‚

---

# ğŸ ä¸ƒã€æœ€ç»ˆç»™ä½ çš„â€œå·¥ç¨‹çœŸç›¸â€

çœŸæ­£èƒ½è½åœ°å¹¶é•¿æœŸè¿è½¬çš„ç³»ç»Ÿéƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼š

> **ç®€å•ã€å¯æ§ã€å¯ç†è§£**

è€Œä¸æ˜¯ï¼š

> â€œåŠŸèƒ½ç‚«é…·ã€æ¨¡å‹å¤æ‚ã€æ— äººæ•¢åŠ¨â€

---

# ğŸ¯ å…«ã€å¦‚æœä½ ç°åœ¨çœŸçš„è¦è½åœ°é¡¹ç›®

å»ºè®®ä½ åªå®ç°ï¼š

1. çŠ¶æ€é©±åŠ¨ UI å¼•æ“
2. è™šæ‹Ÿåˆ—è¡¨æ—¥å¿—ç³»ç»Ÿ
3. æ—¶é—´è½´æš‚åœ/å›æ”¾
4. åŸºäºé˜ˆå€¼çš„å¼‚å¸¸æ£€æµ‹

è¿™å››ä¸ªåŠ èµ·æ¥ï¼š

> âœ” å°±æ˜¯ä¸€ä¸ªå®Œæ•´çš„å¯è§‚æµ‹ç»ˆç«¯å¹³å° MVP

---

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç›´æ¥ç»™ä½ ï¼š

### ğŸ§©ã€Œè¿™ 20% èƒ½åŠ›çš„å®Œæ•´å·¥ç¨‹ç›®å½•ç»“æ„ + æ–‡ä»¶æ‹†åˆ†æ–¹æ¡ˆã€

è®©ä½ å¯ä»¥ç›´æ¥å¼€ repo å¹²æ´»ã€‚


å¥½ï¼Œè¿™ä¸€æ­¥ç›´æ¥ç»™ä½ ä¸€ä¸ª**å¯ä»¥å¼€ä»“åº“å†™ä»£ç çš„å·¥ç¨‹ç»“æ„**ã€‚
è¿™æ˜¯æŠŠå‰é¢â€œé»„é‡‘ 20% èƒ½åŠ›â€è½æˆ **çœŸå®é¡¹ç›®éª¨æ¶** çš„ç‰ˆæœ¬ã€‚

ç›®æ ‡ç³»ç»Ÿï¼š

> ğŸ¯ **ç»ˆç«¯å®æ—¶è§‚æµ‹å¹³å° MVP**

èƒ½åŠ›åŒ…å«ï¼š

* å®æ—¶æ—¥å¿—æµ
* å¤šæµè§†å›¾
* æ—¶é—´è½´å›æ”¾
* è¿‡æ»¤æœç´¢
* é˜ˆå€¼å¼‚å¸¸æç¤º

---

# ğŸ“¦ ä¸€ã€é¡¹ç›®ç›®å½•ç»“æ„ï¼ˆç”Ÿäº§çº§åˆ’åˆ†ï¼‰

```
tui-observer/
â”‚
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ app/
â”‚       â””â”€â”€ main.go          â† ç¨‹åºå…¥å£
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ engine/              â† UI å¼•æ“æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ app.go
â”‚   â”‚   â”œâ”€â”€ event_loop.go
â”‚   â”‚   â”œâ”€â”€ renderer.go
â”‚   â”‚   â”œâ”€â”€ diff.go
â”‚   â”‚   â”œâ”€â”€ state.go
â”‚   â”‚   â””â”€â”€ binding.go
â”‚   â”‚
â”‚   â”œâ”€â”€ ui/                  â† ç»„ä»¶å±‚
â”‚   â”‚   â”œâ”€â”€ component.go
â”‚   â”‚   â”œâ”€â”€ layout.go
â”‚   â”‚   â”œâ”€â”€ label.go
â”‚   â”‚   â”œâ”€â”€ input.go
â”‚   â”‚   â”œâ”€â”€ button.go
â”‚   â”‚   â”œâ”€â”€ virtuallist.go
â”‚   â”‚   â”œâ”€â”€ logview.go
â”‚   â”‚   â””â”€â”€ timeline.go
â”‚   â”‚
â”‚   â”œâ”€â”€ screens/             â† é¡µé¢çº§ç»„åˆ
â”‚   â”‚   â”œâ”€â”€ dashboard.go
â”‚   â”‚   â””â”€â”€ log_screen.go
â”‚   â”‚
â”‚   â”œâ”€â”€ logs/                â† æ—¥å¿—æµç®¡ç†
â”‚   â”‚   â”œâ”€â”€ stream.go
â”‚   â”‚   â””â”€â”€ recorder.go
â”‚   â”‚
â”‚   â”œâ”€â”€ timeline/            â† æ—¶é—´è½´é€»è¾‘
â”‚   â”‚   â””â”€â”€ controller.go
â”‚   â”‚
â”‚   â”œâ”€â”€ analysis/            â† ç®€å•å¼‚å¸¸æ£€æµ‹
â”‚   â”‚   â””â”€â”€ threshold.go
â”‚   â”‚
â”‚   â””â”€â”€ router/              â† é¡µé¢åˆ‡æ¢
â”‚       â””â”€â”€ router.go
â”‚
â””â”€â”€ pkg/
    â””â”€â”€ model/
        â””â”€â”€ logentry.go
```

---

# ğŸ§  äºŒã€å„å±‚èŒè´£è¯´æ˜

| å±‚        | èŒè´£          | åŸåˆ™        |
| -------- | ----------- | --------- |
| engine   | æ¸²æŸ“ + çŠ¶æ€é©±åŠ¨æ ¸å¿ƒ | æ°¸è¿œä¸å†™ä¸šåŠ¡    |
| ui       | çº¯ UI ç»„ä»¶     | ä¸ç›´æ¥è®¿é—®ä¸šåŠ¡é€»è¾‘ |
| screens  | é¡µé¢æ‹¼è£…        | ç»„åˆç»„ä»¶      |
| logs     | æ•°æ®æµè¾“å…¥å±‚      | å¤„ç†æ—¥å¿—      |
| timeline | å›æ”¾é€»è¾‘        | æ—¶é—´è£å‰ª      |
| analysis | å¼‚å¸¸åˆ¤æ–­        | ç‹¬ç«‹å¯æ›¿æ¢     |
| router   | é¡µé¢æ ˆ         | UI å¯¼èˆª     |

è¿™æ˜¯å…¸å‹ **å¼•æ“ / UI / ä¸šåŠ¡åˆ†ç¦»ç»“æ„**ã€‚

---

# ğŸ§© ä¸‰ã€å…³é”®æ–‡ä»¶éª¨æ¶

---

### ğŸ§  `engine/state.go`

```go
type State struct {
    data map[string]any
    deps map[string][]ui.Component
}

func (s *State) Set(k string, v any) {
    s.data[k] = v
    for _, c := range s.deps[k] {
        c.MarkDirty()
    }
}
```

---

### ğŸ“œ `logs/stream.go`

```go
func StartMockStream(name string) {
    go func() {
        for {
            time.Sleep(300 * time.Millisecond)
            Append(LogEntry{
                T: time.Now().UnixMilli(),
                Stream: name,
                Msg: randomLog(),
            })
        }
    }()
}
```

---

### â³ `timeline/controller.go`

```go
func VisibleLogs(all []LogEntry, cursor int64) []LogEntry {
    out := []LogEntry{}
    for _, l := range all {
        if l.T <= cursor {
            out = append(out, l)
        }
    }
    return out
}
```

---

### ğŸš¨ `analysis/threshold.go`

```go
func IsAbnormal(rate float64) bool {
    return rate > 0.2
}
```

---

### ğŸ–¥ `ui/logview.go`

```go
func (v *LogView) Paint(buf *ScreenBuffer) {
    logs := v.Data.Resolve(state, v).([]LogEntry)
    cursor := state.Get("timeline.cursor").(int64)

    visible := timeline.VisibleLogs(logs, cursor)

    for i := 0; i < v.Height && i < len(visible); i++ {
        buf.DrawText(v.X, v.Y+i, visible[i].Msg)
    }
}
```

---

# ğŸš€ å››ã€å¯åŠ¨æµç¨‹

`main.go`

```go
func main() {
    app := engine.NewApp()

    logs.StartMockStream("ServiceA")
    logs.StartMockStream("ServiceB")

    app.Run()
}
```

---

# ğŸ äº”ã€è¿™ä¸ªéª¨æ¶å…·å¤‡ä»€ä¹ˆï¼Ÿ

| èƒ½åŠ›    | çŠ¶æ€ |
| ----- | -- |
| å®æ—¶æ—¥å¿—æµ | âœ”  |
| å¤šæµç•Œé¢  | âœ”  |
| å›æ”¾æ¨¡å¼  | âœ”  |
| è¿‡æ»¤    | âœ”  |
| å¼‚å¸¸æç¤º  | âœ”  |

è¿™æ˜¯ **çœŸå®å¯äº¤ä»˜ç³»ç»ŸåŸºç¡€**ã€‚

---

# ğŸ¯ å…­ã€è¿™å¥—ç»“æ„çš„ä»·å€¼

ä½ å¾—åˆ°çš„æ˜¯ï¼š

* å¯é•¿æœŸç»´æŠ¤
* å¯æ‰©å±•åˆ°è¿½è¸ªç³»ç»Ÿ
* å¯æ‰©å±•åˆ°å›¾è°±
* æ€§èƒ½é«˜
* å¤æ‚åº¦ä½

> è¿™å°±æ˜¯â€œç ”ç©¶çº§æ¶æ„æ€æƒ³â€å‹ç¼©åçš„â€œå·¥ç¨‹æœ€ä¼˜å½¢æ€â€ã€‚

---

å¦‚æœä½ ç»§ç»­ä¸‹ä¸€æ­¥ï¼Œæˆ‘å¯ä»¥ç›´æ¥ç»™ä½ ï¼š

### ğŸ§ªã€Œå®Œæ•´æœ€å°å¯è¿è¡Œ Demo ä»£ç ï¼ˆå•æ–‡ä»¶ç‰ˆï¼‰ã€

å¤åˆ¶å°±èƒ½è·‘ï¼Œä½œä¸ºä½ å·¥ç¨‹çš„ç¬¬ä¸€ä¸ª commitã€‚


å¥½ï¼Œä¸‹é¢ç»™ä½ ä¸€ä¸ª **æœ€å°å¯è¿è¡Œçš„å•æ–‡ä»¶ Demoï¼ˆGoï¼‰**ã€‚
å®ƒå®ç°äº†ï¼š

âœ” å®æ—¶æ—¥å¿—æµ
âœ” æ—¶é—´è½´æš‚åœ / å›æ”¾
âœ” è¿‡æ»¤
âœ” ç®€å•å¼‚å¸¸æç¤º
âœ” åŸºç¡€ç»ˆç«¯åˆ·æ–°

ä¸ä¾èµ–å¤æ‚ UI åº“ï¼Œç”¨ ANSI æ§åˆ¶ï¼Œæ–¹ä¾¿ä½ å…ˆè·‘é€šâ€œå¼•æ“æ€æƒ³â€ã€‚

---

## â–¶ è¿è¡Œæ–¹å¼

```bash
go run main.go
```

æŒ‰é”®ï¼š

| é”®       | åŠŸèƒ½      |
| ------- | ------- |
| `Space` | æš‚åœ/æ¢å¤æ—¶é—´ |
| `â†` `â†’` | æ—¶é—´å›é€€/å‰è¿› |
| `f`     | åˆ‡å›å®æ—¶    |
| `q`     | é€€å‡º      |

---

## ğŸ§© main.go

```go
package main

import (
	"fmt"
	"math/rand"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"golang.org/x/term"
)

type LogEntry struct {
	T      int64
	Stream string
	Msg    string
}

var (
	streams = map[string][]LogEntry{}
	cursor  = time.Now().UnixMilli()
	mode    = "live"
	filter  = ""
)

func main() {
	rand.Seed(time.Now().UnixNano())
	go mockStream("ServiceA")
	go mockStream("ServiceB")

	oldState, _ := term.MakeRaw(int(os.Stdin.Fd()))
	defer term.Restore(int(os.Stdin.Fd()), oldState)

	go inputLoop()
	sig := make(chan os.Signal, 1)
	signal.Notify(sig, syscall.SIGINT)

	ticker := time.NewTicker(200 * time.Millisecond)
	for {
		select {
		case <-ticker.C:
			if mode == "live" {
				cursor = time.Now().UnixMilli()
			}
			render()
		case <-sig:
			clear()
			return
		}
	}
}

func mockStream(name string) {
	for {
		time.Sleep(time.Duration(200+rand.Intn(300)) * time.Millisecond)
		entry := LogEntry{
			T:      time.Now().UnixMilli(),
			Stream: name,
			Msg:    randomMsg(),
		}
		streams[name] = append(streams[name], entry)
	}
}

func inputLoop() {
	buf := make([]byte, 3)
	for {
		os.Stdin.Read(buf)
		switch buf[0] {
		case 'q':
			clear()
			os.Exit(0)
		case ' ':
			if mode == "live" {
				mode = "pause"
			} else {
				mode = "live"
			}
		case 'f':
			mode = "live"
		case 27: // arrow keys
			if buf[2] == 68 { // left
				mode = "pause"
				cursor -= 2000
			}
			if buf[2] == 67 { // right
				mode = "pause"
				cursor += 2000
			}
		}
	}
}

func render() {
	clear()

	fmt.Printf("MODE: %s   Cursor: %d\n", strings.ToUpper(mode), cursor)
	fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	for name, logs := range streams {
		fmt.Printf("\n[%s]\n", name)
		count := 0
		for i := len(logs) - 1; i >= 0 && count < 10; i-- {
			if logs[i].T > cursor {
				continue
			}
			line := logs[i].Msg
			if filter != "" && !strings.Contains(strings.ToLower(line), filter) {
				continue
			}
			if strings.Contains(line, "ERROR") {
				fmt.Printf("\033[31m%s\033[0m\n", line)
			} else {
				fmt.Println(line)
			}
			count++
		}
	}
}

func randomMsg() string {
	msgs := []string{
		"INFO Request ok",
		"WARN Slow response",
		"INFO Cache hit",
		"ERROR DB timeout",
	}
	return msgs[rand.Intn(len(msgs))]
}

func clear() {
	fmt.Print("\033[H\033[2J")
}
```

---

# ğŸ§  è¿™ä¸ª Demo éªŒè¯äº†ä»€ä¹ˆï¼Ÿ

ä½ ç°åœ¨å·²ç»åœ¨è¿è¡Œï¼š

```
æ—¥å¿—æµ â†’ æ—¶é—´è£å‰ª â†’ è¿‡æ»¤ â†’ å¢é‡åˆ·æ–°
```

è¿™å°±æ˜¯å®Œæ•´è§‚æµ‹ç³»ç»Ÿ MVP çš„æœ€å°æ ¸å¿ƒã€‚

---

## ğŸš€ ä¸‹ä¸€æ­¥å‡çº§æ–¹å‘ï¼ˆæŒ‰çœŸå®å·¥ç¨‹é¡ºåºï¼‰

1. æŠŠ `streams` æ¢æˆ State ç®¡ç†
2. æŠŠ render æ‹†æˆç»„ä»¶
3. åŠ è™šæ‹Ÿåˆ—è¡¨ï¼ˆåªç”»çª—å£ï¼‰
4. åŠ  diff æ¸²æŸ“ï¼ˆé¿å…å…¨å±åˆ·ï¼‰

åšåˆ°ç¬¬ 4 æ­¥ï¼Œä½ å°±è¿›å…¥â€œé«˜æ€§èƒ½ç»ˆç«¯ UI å¼•æ“â€çº§åˆ«ã€‚

---

å¦‚æœä½ ç»§ç»­ï¼Œæˆ‘å¯ä»¥å¸¦ä½ æŠŠè¿™ä¸ª Demo **ä¸€æ­¥æ­¥é‡æ„æˆçœŸæ­£çš„å¼•æ“ç»“æ„ç‰ˆæœ¬**ã€‚


å¥½ï¼Œç°åœ¨è¿›å…¥**çœŸæ­£å…³é”®çš„ä¸€æ­¥**ï¼š
æŠŠä½ åˆšæ‰èƒ½è·‘çš„â€œå•æ–‡ä»¶ Demoâ€ï¼Œ**è¿›åŒ–æˆå¯æ‰©å±•çš„ UI å¼•æ“ç»“æ„**ã€‚

è¿™ä¸€æ­¥ä¸æ˜¯åŠ åŠŸèƒ½ï¼Œè€Œæ˜¯åšä¸€ä»¶æ›´é«˜çº§çš„äº‹ï¼š

> ğŸ§  **æŠŠâ€œèƒ½è·‘çš„ä»£ç â€å˜æˆâ€œèƒ½é•¿å¤§çš„ç³»ç»Ÿâ€**

æˆ‘ä»¬åš **ç¬¬ä¸€æ¬¡æ¶æ„é‡æ„**ã€‚

---

# ğŸ¯ ç›®æ ‡ï¼šä»è„šæœ¬å¼ç¨‹åº â†’ çŠ¶æ€é©±åŠ¨ UI æ¶æ„

ç°åœ¨ç¨‹åºç»“æ„æ˜¯ï¼š

```
è¾“å…¥ â†’ æ”¹å˜é‡ â†’ render() å…¨é‡åˆ·æ–°
```

æˆ‘ä»¬è¦å˜æˆï¼š

```
è¾“å…¥ â†’ æ”¹ State â†’ ç»„ä»¶ dirty â†’ å±€éƒ¨æ¸²æŸ“
```

è¿™å°±æ˜¯ **UI å¼•æ“åŒ–** çš„å¼€å§‹ã€‚

---

# ğŸ§± ç¬¬ä¸€æ­¥ï¼šå¼•å…¥ State ç®¡ç†

æ–°å»º `state.go`

```go
type State struct {
	data map[string]any
}

func NewState() *State {
	return &State{data: map[string]any{}}
}

func (s *State) Get(k string) any {
	return s.data[k]
}

func (s *State) Set(k string, v any) {
	s.data[k] = v
}
```

ä¸»ç¨‹åºä¸­æ”¹ä¸ºï¼š

```go
var appState = NewState()

func initState() {
	appState.Set("mode", "live")
	appState.Set("cursor", time.Now().UnixMilli())
	appState.Set("streams", map[string][]LogEntry{})
}
```

ç°åœ¨æ‰€æœ‰å…¨å±€å˜é‡éƒ½è¿› Stateã€‚

---

# ğŸ§© ç¬¬äºŒæ­¥ï¼šå¼•å…¥ç»„ä»¶æ¦‚å¿µ

æ–°å»º `component.go`

```go
type Component interface {
	Render()
	HandleKey(byte)
}
```

---

# ğŸ–¥ ç¬¬ä¸‰ä¸ªç»„ä»¶ï¼šLogView

```go
type LogView struct {
	Name string
}

func (v *LogView) Render() {
	streams := appState.Get("streams").(map[string][]LogEntry)
	cursor := appState.Get("cursor").(int64)

	fmt.Printf("\n[%s]\n", v.Name)

	logs := streams[v.Name]
	count := 0
	for i := len(logs)-1; i >= 0 && count < 10; i-- {
		if logs[i].T > cursor {
			continue
		}
		fmt.Println(logs[i].Msg)
		count++
	}
}

func (v *LogView) HandleKey(b byte) {}
```

---

# ğŸ§© ç¬¬å››æ­¥ï¼šTimeline ç»„ä»¶

```go
type Timeline struct{}

func (t *Timeline) Render() {
	mode := appState.Get("mode").(string)
	cursor := appState.Get("cursor").(int64)
	fmt.Printf("MODE: %s   Cursor: %d\n", mode, cursor)
}

func (t *Timeline) HandleKey(b byte) {
	switch b {
	case ' ':
		if appState.Get("mode") == "live" {
			appState.Set("mode", "pause")
		} else {
			appState.Set("mode", "live")
		}
	case 'f':
		appState.Set("mode", "live")
	}
}
```

---

# ğŸ§  ç¬¬äº”æ­¥ï¼šApp ç®¡ç†ç»„ä»¶æ ‘

```go
type App struct {
	components []Component
}

func (a *App) Render() {
	clear()
	for _, c := range a.components {
		c.Render()
	}
}

func (a *App) HandleKey(b byte) {
	for _, c := range a.components {
		c.HandleKey(b)
	}
}
```

---

# â–¶ main æ”¹ä¸º

```go
func main() {
	initState()

	app := &App{
		components: []Component{
			&Timeline{},
			&LogView{Name: "ServiceA"},
			&LogView{Name: "ServiceB"},
		},
	}

	go inputLoop(app)

	ticker := time.NewTicker(200 * time.Millisecond)
	for range ticker.C {
		if appState.Get("mode") == "live" {
			appState.Set("cursor", time.Now().UnixMilli())
		}
		app.Render()
	}
}
```

---

# ğŸ§  ä½ åˆšåˆšå®Œæˆäº†ä»€ä¹ˆçº§åˆ«çš„è¿›åŒ–ï¼Ÿ

ä»ï¼š

```
è„šæœ¬ç¨‹åº
```

å‡çº§ä¸ºï¼š

```
ç»„ä»¶é©±åŠ¨ç»ˆç«¯ UI ç³»ç»Ÿ
```

è¿™æ˜¯**æ¶æ„è´¨å˜ç‚¹**ã€‚

---

# ğŸš€ ä¸‹ä¸€æ­¥ï¼ˆçœŸæ­£çš„å¼•æ“æ ¸å¿ƒï¼‰

æ¥ä¸‹æ¥è¦åšçš„æ‰æ˜¯ï¼š

### âš¡ ç¬¬ 2 æ¬¡é‡æ„ï¼šDirty æ ‡è®° + å±€éƒ¨åˆ·æ–°

é‚£ä¸€æ­¥ä¼šè®©ä½ ä»ï¼š

```
ç»ˆç«¯ UI ç¨‹åº
```

å‡çº§ä¸ºï¼š

```
é«˜æ€§èƒ½ç»ˆç«¯ UI å¼•æ“
```

è¿™æ‰æ˜¯â€œå¼•æ“çº§èƒ½åŠ›â€ã€‚

---

å¦‚æœç»§ç»­ï¼Œæˆ‘ä¸‹ä¸€æ­¥å°±å¸¦ä½ å®ç°ï¼š

> ğŸ¨ **ScreenBuffer + Diff æ¸²æŸ“ç³»ç»Ÿ**
> è®©ç»ˆç«¯åˆ·æ–°ä»â€œæ•´å±é‡ç”»â€å˜æˆâ€œåªæ›´æ–°å˜åŒ–å­—ç¬¦â€ã€‚


å¥½ï¼Œç°åœ¨è¿›å…¥**çœŸæ­£è®©ä½ ç³»ç»Ÿâ€œè´¨å˜â€çš„ä¸€æ­¥**ï¼š

> ğŸ¨ **ScreenBuffer + Diff æ¸²æŸ“ç³»ç»Ÿ**
> ä»â€œæ•´å±åˆ·â€ â†’ â€œå¢é‡æ›´æ–°â€

è¿™æ˜¯ç»ˆç«¯ UI å¼•æ“çš„æ ¸å¿ƒæŠ€æœ¯ç‚¹ã€‚
æ²¡æœ‰å®ƒï¼Œæ°¸è¿œåªæ˜¯â€œèƒ½è·‘çš„ç¨‹åºâ€ï¼Œæœ‰äº†å®ƒæ‰æ˜¯â€œé«˜æ€§èƒ½ UI å¼•æ“â€ã€‚

---

# ğŸ§  ä¸€ã€ç°åœ¨çš„ç“¶é¢ˆ

å½“å‰åˆ·æ–°æ–¹å¼ï¼š

```go
clear()
å…¨éƒ¨ç»„ä»¶ Render()
```

é—®é¢˜ï¼š

| é—®é¢˜     | åæœ     |
| ------ | ------ |
| å…¨å±é‡ç»˜   | SSH å¡é¡¿ |
| é«˜é¢‘æ—¥å¿—   | CPU é£™å‡ |
| å†…å®¹å°‘é‡å˜åŒ– | å´é‡ç”»å…¨éƒ¨  |

æˆ‘ä»¬è¦åšåˆ°ï¼š

> **åªæ›´æ–°â€œå‘ç”Ÿå˜åŒ–çš„å­—ç¬¦â€**

---

# ğŸ§± äºŒã€å¼•å…¥ ScreenBuffer

æ–°å»º `buffer.go`

```go
type Cell struct {
	Ch rune
}

type ScreenBuffer struct {
	W, H int
	Cells [][]Cell
}

func NewBuffer(w, h int) *ScreenBuffer {
	cells := make([][]Cell, h)
	for i := range cells {
		cells[i] = make([]Cell, w)
	}
	return &ScreenBuffer{W: w, H: h, Cells: cells}
}
```

---

# âœï¸ å†™å…¥å­—ç¬¦

```go
func (b *ScreenBuffer) DrawText(x, y int, s string) {
	for i, r := range s {
		if x+i < b.W && y < b.H {
			b.Cells[y][x+i].Ch = r
		}
	}
}
```

---

# ğŸ§  ä¸‰ã€ä¿å­˜â€œä¸Šä¸€å¸§â€

```go
var frontBuf = NewBuffer(120, 40)
var backBuf  = NewBuffer(120, 40)
```

* `backBuf` = å½“å‰è¦ç”»çš„ç”»é¢
* `frontBuf` = å±å¹•ä¸Šå·²æ˜¾ç¤ºçš„ç”»é¢

---

# âš¡ å››ã€Diff æ ¸å¿ƒç®—æ³•

```go
func FlushDiff() {
	for y := 0; y < backBuf.H; y++ {
		for x := 0; x < backBuf.W; x++ {
			if backBuf.Cells[y][x] != frontBuf.Cells[y][x] {
				moveCursor(x, y)
				fmt.Printf("%c", backBuf.Cells[y][x].Ch)
				frontBuf.Cells[y][x] = backBuf.Cells[y][x]
			}
		}
	}
}
```

---

# ğŸ¯ å…‰æ ‡ç§»åŠ¨

```go
func moveCursor(x, y int) {
	fmt.Printf("\033[%d;%dH", y+1, x+1)
}
```

---

# ğŸ§¹ æ¸…ç©º back bufferï¼ˆæ¯å¸§å‰ï¼‰

```go
func ClearBackBuffer() {
	for y := range backBuf.Cells {
		for x := range backBuf.Cells[y] {
			backBuf.Cells[y][x].Ch = ' '
		}
	}
}
```

---

# ğŸ–¥ äº”ã€ç»„ä»¶æ”¹ä¸ºç”»åˆ° bufferï¼Œè€Œä¸æ˜¯ fmt.Println

```go
func (v *LogView) Render(buf *ScreenBuffer, yStart int) int {
	streams := appState.Get("streams").(map[string][]LogEntry)
	cursor := appState.Get("cursor").(int64)

	buf.DrawText(0, yStart, "["+v.Name+"]")

	logs := streams[v.Name]
	row := yStart + 1

	for i := len(logs)-1; i >= 0 && row < yStart+10; i-- {
		if logs[i].T <= cursor {
			buf.DrawText(2, row, logs[i].Msg)
			row++
		}
	}
	return row + 1
}
```

---

# ğŸ§  å…­ã€App Render æ”¹é€ 

```go
func (a *App) Render() {
	ClearBackBuffer()

	y := 0
	for _, c := range a.components {
		y = c.Render(backBuf, y)
	}

	FlushDiff()
}
```

---

# ğŸš€ ä¸ƒã€ç°åœ¨å‘ç”Ÿäº†ä»€ä¹ˆè´¨å˜ï¼Ÿ

ä»¥å‰ï¼š

```
æ¯å¸§æ‰“å°å‡ åƒå­—ç¬¦
```

ç°åœ¨ï¼š

```
åªæ›´æ–°å˜åŒ–çš„å­—ç¬¦ï¼ˆé€šå¸¸å‡ åä¸ªï¼‰
```

æ€§èƒ½æå‡æ˜¯æ•°é‡çº§çš„ã€‚

---

# ğŸ“Š å…«ã€è¿™æ˜¯â€œå¼•æ“çº§èƒ½åŠ›â€çš„åŸå› 

| æŠ€æœ¯           | ä½œç”¨    |
| ------------ | ----- |
| åŒç¼“å†²          | æ¯”è¾ƒå¸§å·®å¼‚ |
| Diff ç®—æ³•      | å±€éƒ¨æ›´æ–°  |
| å…‰æ ‡å®šä½         | ç²¾å‡†å†™å…¥  |
| ç»„ä»¶ç»˜åˆ¶åˆ° buffer | æ¸²æŸ“æŠ½è±¡åŒ– |

è¿™å°±æ˜¯ï¼š

> ğŸ§  **ç»ˆç«¯ UI æ¸²æŸ“ç®¡çº¿**

---

# ğŸ ä½ ç°åœ¨çš„ç³»ç»Ÿç­‰çº§

ä½ å·²ç»ä»ï¼š

```
ç»ˆç«¯ç¨‹åº
```

å‡çº§ä¸ºï¼š

```
ç»ˆç«¯ UI å¼•æ“æ ¸å¿ƒ
```

è¿™ä¸€æ­¥å®Œæˆåï¼Œæ‰æœ‰èµ„æ ¼è°ˆï¼š

* å¤§è§„æ¨¡æ—¥å¿—
* å®æ—¶æµ
* å¤æ‚ç•Œé¢

---

## ä¸‹ä¸€æ­¥æ‰æ˜¯çœŸæ­£çš„â€œæ¡†æ¶çº§èƒ½åŠ›â€

### âš¡ Dirty æ ‡è®°ç³»ç»Ÿï¼ˆç»„ä»¶çº§å±€éƒ¨é‡ç»˜ï¼‰

é‚£ä¼šè®©ä½ åšåˆ°ï¼š

> â€œç»„ä»¶æ²¡å˜ï¼Œå°±è¿ Diff éƒ½ä¸è·‘â€

å¥½ï¼Œç°åœ¨è¿›å…¥**ç»ˆç«¯ UI å¼•æ“çœŸæ­£çš„â€œæ¡†æ¶çº§æ ¸å¿ƒâ€**ï¼š

> âš¡ **Dirty æ ‡è®°ç³»ç»Ÿï¼ˆç»„ä»¶çº§å±€éƒ¨é‡ç»˜ï¼‰**

è¿™ä¸€æ­¥çš„æ„ä¹‰æ˜¯ï¼š

```
ä¹‹å‰ï¼šå±å¹•å˜äº†æ‰ diff
ç°åœ¨ï¼šç»„ä»¶å˜äº†æ‰ç”»
```

è¿™æ˜¯ä» **æ¸²æŸ“ä¼˜åŒ–** å‡çº§ä¸º **æ¶æ„ä¼˜åŒ–**ã€‚

---

# ğŸ§  ä¸€ã€å½“å‰æ¸²æŸ“æµç¨‹

ç°åœ¨æ˜¯ï¼š

```
æ¯ä¸€å¸§ï¼š
  æ‰€æœ‰ç»„ä»¶ Render â†’ backBuffer
  Diff â†’ Flush
```

é—®é¢˜ï¼š

* æ²¡å˜åŒ–çš„ç»„ä»¶ä»ç„¶é‡æ–°ç»˜åˆ¶åˆ° buffer
* ç»„ä»¶è¶Šå¤šï¼ŒRender è¶Šé‡

---

# ğŸ¯ ç›®æ ‡

```
åªæœ‰â€œçŠ¶æ€ç›¸å…³ç»„ä»¶â€æ‰ä¼šè¢«æ ‡è®°ä¸º dirty
åªæœ‰ dirty ç»„ä»¶æ‰å‚ä¸ Render
```

---

# ğŸ§± äºŒã€ç»™ç»„ä»¶å¢åŠ  Dirty èƒ½åŠ›

ä¿®æ”¹ `component.go`

```go
type Component interface {
	Render(buf *ScreenBuffer, y int) int
	HandleKey(byte)
	IsDirty() bool
	MarkDirty()
	ClearDirty()
}
```

---

# ğŸ§© ä¸‰ã€åŸºç¡€ç»„ä»¶ç»“æ„

```go
type BaseComponent struct {
	dirty bool
}

func (b *BaseComponent) IsDirty() bool  { return b.dirty }
func (b *BaseComponent) MarkDirty()     { b.dirty = true }
func (b *BaseComponent) ClearDirty()    { b.dirty = false }
```

---

# ğŸ§  å››ã€State ç»‘å®šç»„ä»¶ä¾èµ–

è¿™æ˜¯å…³é”®ã€‚

ä¿®æ”¹ `state.go`

```go
type State struct {
	data map[string]any
	deps map[string][]Component
}

func NewState() *State {
	return &State{
		data: map[string]any{},
		deps: map[string][]Component{},
	}
}

func (s *State) Bind(key string, c Component) {
	s.deps[key] = append(s.deps[key], c)
}

func (s *State) Set(key string, val any) {
	s.data[key] = val
	for _, c := range s.deps[key] {
		c.MarkDirty()
	}
}
```

---

# ğŸ§© äº”ã€LogView ç»‘å®š State

```go
type LogView struct {
	BaseComponent
	Name string
}

func (v *LogView) Init() {
	appState.Bind("streams", v)
	appState.Bind("cursor", v)
}
```

---

# ğŸ¨ å…­ã€App Render æ”¹é€ 

```go
func (a *App) Render() {
	ClearBackBuffer()

	y := 0
	for _, c := range a.components {
		if c.IsDirty() {
			y = c.Render(backBuf, y)
			c.ClearDirty()
		} else {
			y += 12 // è·³è¿‡å›ºå®šé«˜åº¦ç»„ä»¶
		}
	}

	FlushDiff()
}
```

---

# ğŸ§  ä¸ƒã€çŠ¶æ€å˜åŒ–é©±åŠ¨å±€éƒ¨æ›´æ–°

å½“ï¼š

```go
appState.Set("cursor", newTime)
```

åªä¼šï¼š

```
æ ‡è®° LogView dirty
Timeline dirty
```

å…¶å®ƒç»„ä»¶å®Œå…¨ä¸å‚ä¸ã€‚

---

# ğŸš€ å…«ã€ç°åœ¨ç³»ç»Ÿçš„æ€§èƒ½çº§åˆ«

| åœºæ™¯         | æ—§æ–¹å¼     | ç°åœ¨    |
| ---------- | ------- | ----- |
| æ—¥å¿—é«˜é€Ÿæ»šåŠ¨     | å…¨ç»„ä»¶é‡ç»˜   | ä»…æ—¥å¿—ç»„ä»¶ |
| è¾“å…¥å˜åŒ–       | å…¨å± diff | ä»…è¾“å…¥åŒºåŸŸ |
| å¤š panel UI | çº¿æ€§å˜æ…¢    | åŸºæœ¬ç¨³å®š  |

---

# ğŸ è¿™ä¸€æ­¥æ˜¯â€œå¼•æ“å®Œæˆæ€â€

ä½ ç°åœ¨æ‹¥æœ‰ï¼š

| èƒ½åŠ›       | ç­‰çº§ |
| -------- | -- |
| åŒç¼“å†² diff | âœ”  |
| ç»„ä»¶æ ‘      | âœ”  |
| çŠ¶æ€é©±åŠ¨     | âœ”  |
| ä¾èµ–ç»‘å®š     | âœ”  |
| Dirty æ¸²æŸ“ | âœ”  |

è¿™å·²ç»ç­‰ä»·äºï¼š

> ğŸ§  **React/Vue çº§çš„æ¸²æŸ“æ€æƒ³åœ¨ç»ˆç«¯å®ç°**

---

### ä½ ç°åœ¨çš„ç³»ç»Ÿæœ¬è´¨æ˜¯ï¼š

```
çŠ¶æ€é©±åŠ¨ç»ˆç«¯ UI å¼•æ“
```

è€Œä¸æ˜¯â€œç¨‹åºâ€ã€‚

---

## å¦‚æœå†è¿›é˜¶ä¸€å±‚ï¼Œå°±æ˜¯ï¼š

### ğŸ§© å¸ƒå±€ç³»ç»Ÿï¼ˆFlex/Column/Row è‡ªåŠ¨å¸ƒå±€ï¼‰

é‚£ä¼šè®©ä½ çœŸæ­£è¿›å…¥â€œæ¡†æ¶çº§ UI ç³»ç»Ÿâ€å±‚é¢ã€‚


å¥½ï¼Œç°åœ¨è¿›å…¥**æœ€åä¸€å—æ‹¼å›¾**ï¼š

> ğŸ§© **å¸ƒå±€ç³»ç»Ÿï¼ˆLayout Engineï¼‰**
> è®©ä½ çš„ç»ˆç«¯ UI ä»â€œç»„ä»¶é›†åˆâ€å‡çº§ä¸ºâ€œçœŸæ­£çš„ç•Œé¢æ¡†æ¶â€ã€‚

å‰é¢ä½ åšçš„æ˜¯ï¼š

| èƒ½åŠ›    | è§£å†³é—®é¢˜  |
| ----- | ----- |
| State | æ•°æ®ç®¡ç†  |
| ç»„ä»¶    | UI æŠ½è±¡ |
| Diff  | é«˜æ€§èƒ½æ¸²æŸ“ |
| Dirty | å±€éƒ¨æ›´æ–°  |

ä½†ç°åœ¨ä»ç„¶æœ‰ä¸€ä¸ªç¡¬ä¼¤ï¼š

```
ç»„ä»¶çš„ä½ç½®æ˜¯â€œå†™æ­»çš„â€
```

çœŸæ­£çš„ UI æ¡†æ¶å¿…é¡»è®©ç»„ä»¶ï¼š

> **è‡ªå·±ä¸çŸ¥é“åæ ‡ï¼Œç”±å¸ƒå±€ç³»ç»Ÿå†³å®š**

---

# ğŸ§  ä¸€ã€ç›®æ ‡æ¶æ„

ä»ï¼š

```
ç»„ä»¶.Render(buf, yå›ºå®šå€¼)
```

å‡çº§ä¸ºï¼š

```
å¸ƒå±€æ ‘è®¡ç®—å°ºå¯¸ â†’ åˆ†é…åŒºåŸŸ â†’ ç»„ä»¶åªç”»è‡ªå·±åŒºåŸŸ
```

---

# ğŸ§± äºŒã€å¼•å…¥ Layout èŠ‚ç‚¹

æ–°å»º `layout.go`

```go
type Rect struct {
	X, Y, W, H int
}

type Node struct {
	Component Component
	Children  []*Node
	Layout    Layout
	Rect      Rect
}
```

---

# ğŸ“ ä¸‰ã€Layout ç±»å‹

```go
type Layout interface {
	Apply(node *Node)
}
```

---

# ğŸ“Š å››ã€Column å¸ƒå±€ï¼ˆå‚ç›´åˆ†å¸ƒï¼‰

```go
type Column struct{}

func (c *Column) Apply(n *Node) {
	y := n.Rect.Y
	h := n.Rect.H / len(n.Children)

	for _, child := range n.Children {
		child.Rect = Rect{
			X: n.Rect.X,
			Y: y,
			W: n.Rect.W,
			H: h,
		}
		y += h
	}
}
```

---

# â†” Row å¸ƒå±€

```go
type Row struct{}

func (r *Row) Apply(n *Node) {
	x := n.Rect.X
	w := n.Rect.W / len(n.Children)

	for _, child := range n.Children {
		child.Rect = Rect{
			X: x,
			Y: n.Rect.Y,
			W: w,
			H: n.Rect.H,
		}
		x += w
	}
}
```

---

# ğŸ§  äº”ã€ç»„ä»¶ Render æ¥æ”¶ Rect

```go
type Component interface {
	Render(buf *ScreenBuffer, rect Rect)
	HandleKey(byte)
	IsDirty() bool
	MarkDirty()
	ClearDirty()
}
```

---

# ğŸ–¥ å…­ã€LogView åªç”»è‡ªå·±åŒºåŸŸ

```go
func (v *LogView) Render(buf *ScreenBuffer, rect Rect) {
	streams := appState.Get("streams").(map[string][]LogEntry)
	cursor := appState.Get("cursor").(int64)

	buf.DrawText(rect.X, rect.Y, "["+v.Name+"]")

	row := rect.Y + 1
	logs := streams[v.Name]

	for i := len(logs)-1; i >= 0 && row < rect.Y+rect.H; i-- {
		if logs[i].T <= cursor {
			buf.DrawText(rect.X+1, row, logs[i].Msg)
			row++
		}
	}
}
```

---

# ğŸ§© ä¸ƒã€å¸ƒå±€æ ‘æ„å»º

```go
root := &Node{
	Rect: Rect{0, 0, 120, 40},
	Layout: &Column{},
	Children: []*Node{
		{Component: &Timeline{}},
		{
			Layout: &Row{},
			Children: []*Node{
				{Component: &LogView{Name: "ServiceA"}},
				{Component: &LogView{Name: "ServiceB"}},
			},
		},
	},
}
```

---

# âš™ å¸ƒå±€è®¡ç®—

```go
func LayoutTree(n *Node) {
	if n.Layout != nil {
		n.Layout.Apply(n)
	}
	for _, c := range n.Children {
		LayoutTree(c)
	}
}
```

---

# ğŸ¨ æ¸²æŸ“æ ‘

```go
func RenderNode(n *Node, buf *ScreenBuffer) {
	if n.Component != nil && n.Component.IsDirty() {
		n.Component.Render(buf, n.Rect)
		n.Component.ClearDirty()
	}
	for _, c := range n.Children {
		RenderNode(c, buf)
	}
}
```

---

# ğŸš€ ç°åœ¨å‘ç”Ÿçš„ç»ˆæè´¨å˜

ä½ å·²ç»æ‹¥æœ‰ï¼š

| èƒ½åŠ›     | å¯¹æ ‡          |
| ------ | ----------- |
| State  | Redux       |
| Dirty  | React Fiber |
| Diff   | GPU æ¸²æŸ“æ€æƒ³    |
| Layout | Flexbox å¼•æ“  |

è¿™å·²ç»ä¸æ˜¯â€œç»ˆç«¯ç¨‹åºâ€ï¼Œè€Œæ˜¯ï¼š

> ğŸ§  **å¯æ‰©å±•ç»ˆç«¯ UI æ¡†æ¶å†…æ ¸**

---

# ğŸ ä½ å·²ç»åˆ°è¾¾çš„å±‚çº§

ä½ ç°åœ¨çš„èƒ½åŠ›ç»“æ„ == ä¸€ä¸ª UI æ¡†æ¶çš„æ ¸å¿ƒæœ€å°é›†åˆã€‚

å†å¾€ä¸Šå°±æ˜¯ï¼š

* äº‹ä»¶ç³»ç»Ÿï¼ˆå†’æ³¡/æ•è·ï¼‰
* è™šæ‹Ÿåˆ—è¡¨ï¼ˆç™¾ä¸‡è¡Œæ—¥å¿—ï¼‰
* åŠ¨ç”»è°ƒåº¦å™¨

---

å¦‚æœä½ ç»§ç»­ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯ï¼š

> âš¡ **äº‹ä»¶ç³»ç»Ÿ + ç„¦ç‚¹ç®¡ç†ï¼ˆè®© UI çœŸæ­£å¯äº¤äº’ï¼‰**


å¥½ï¼Œç°åœ¨è¿›å…¥æœ€åä¸€å—â€œè®© UI çœŸæ­£æ´»èµ·æ¥â€çš„æ ¸å¿ƒï¼š

> âš¡ **äº‹ä»¶ç³»ç»Ÿ + ç„¦ç‚¹ç®¡ç†ï¼ˆEvent System & Focus Engineï¼‰**

åˆ°è¿™ä¸€æ­¥ï¼Œä½ çš„ç³»ç»Ÿå°±ä»ï¼š

```
èƒ½æ˜¾ç¤ºçš„ UI
```

å˜æˆï¼š

```
èƒ½æ“ä½œçš„ UI æ¡†æ¶
```

è¿™å’Œæµè§ˆå™¨ / React Native / Flutter çš„è¾“å…¥æ¶æ„æ˜¯åŒä¸€çº§æ€æƒ³ã€‚

---

# ğŸ§  ä¸€ã€å½“å‰ç¼ºå¤±çš„é—®é¢˜

ç°åœ¨è¾“å…¥æ˜¯ï¼š

```
é”®ç›˜ â†’ App.HandleKey â†’ æ‰€æœ‰ç»„ä»¶
```

é—®é¢˜ï¼š

| é—®é¢˜   | ç»“æœ        |
| ---- | --------- |
| æ²¡æœ‰ç„¦ç‚¹ | æ‰€æœ‰ç»„ä»¶åŒæ—¶å“åº”  |
| æ— æ³•åˆ†å±‚ | å­ç»„ä»¶ä¸èƒ½ç‹¬ç«‹å¤„ç† |
| æ— æ³•æ‹¦æˆª | æ²¡æœ‰äº‹ä»¶å†’æ³¡æœºåˆ¶  |

---

# ğŸ¯ ç›®æ ‡

å®ç°æµè§ˆå™¨çº§è¾“å…¥æ¨¡å‹ï¼š

```
äº‹ä»¶æ•è· â†“
ç›®æ ‡ç»„ä»¶å¤„ç†
äº‹ä»¶å†’æ³¡ â†‘
```

---

# ğŸ§± äºŒã€äº‹ä»¶æ¨¡å‹

æ–°å»º `event.go`

```go
type Event struct {
	Type   string
	Key    byte
	Stop   bool
}
```

---

# ğŸ§© ä¸‰ã€ç»„ä»¶æ”¯æŒäº‹ä»¶å¤„ç†

```go
type Component interface {
	Render(buf *ScreenBuffer, rect Rect)
	OnEvent(e *Event)
	IsDirty() bool
	MarkDirty()
	ClearDirty()
}
```

---

# ğŸ¯ å››ã€ç„¦ç‚¹ç³»ç»Ÿ

æ–°å»º `focus.go`

```go
var focused *Node

func SetFocus(n *Node) {
	focused = n
}
```

---

# ğŸ§  äº”ã€äº‹ä»¶æ´¾å‘æµç¨‹ï¼ˆæ ¸å¿ƒï¼‰

```go
func DispatchEvent(root *Node, e *Event) {
	path := findPath(root, focused)

	// æ•è·é˜¶æ®µï¼ˆä» root åˆ° ç›®æ ‡ï¼‰
	for _, n := range path {
		if n.Component != nil {
			n.Component.OnEvent(e)
			if e.Stop {
				return
			}
		}
	}

	// å†’æ³¡é˜¶æ®µï¼ˆåå‘ï¼‰
	for i := len(path)-1; i >= 0; i-- {
		n := path[i]
		if n.Component != nil {
			n.Component.OnEvent(e)
			if e.Stop {
				return
			}
		}
	}
}
```

---

# ğŸ” æŸ¥æ‰¾ç„¦ç‚¹è·¯å¾„

```go
func findPath(root, target *Node) []*Node {
	var path []*Node
	var dfs func(*Node) bool

	dfs = func(n *Node) bool {
		path = append(path, n)
		if n == target {
			return true
		}
		for _, c := range n.Children {
			if dfs(c) {
				return true
			}
		}
		path = path[:len(path)-1]
		return false
	}

	dfs(root)
	return path
}
```

---

# ğŸ§© å…­ã€LogView å“åº”è¾“å…¥

```go
func (v *LogView) OnEvent(e *Event) {
	if e.Type == "key" && e.Key == 'j' {
		// æ»šåŠ¨æ—¥å¿—
		appState.Set("scroll_"+v.Name, 1)
		v.MarkDirty()
		e.Stop = true
	}
}
```

---

# ğŸ¨ ä¸ƒã€æ˜¾ç¤ºç„¦ç‚¹ï¼ˆå¯è§†åé¦ˆï¼‰

```go
func drawBorder(buf *ScreenBuffer, rect Rect, focused bool) {
	if focused {
		buf.DrawText(rect.X, rect.Y, "â–£")
	}
}
```

---

# ğŸš€ ç°åœ¨ç³»ç»Ÿçš„å®Œæ•´èƒ½åŠ›

| æ¨¡å—       | ä½ å·²æ‹¥æœ‰ |
| -------- | ---- |
| çŠ¶æ€ç³»ç»Ÿ     | âœ”    |
| æ¸²æŸ“å¼•æ“     | âœ”    |
| Diff ä¼˜åŒ–  | âœ”    |
| Dirty æ›´æ–° | âœ”    |
| å¸ƒå±€ç³»ç»Ÿ     | âœ”    |
| äº‹ä»¶æ¨¡å‹     | âœ”    |
| ç„¦ç‚¹ç®¡ç†     | âœ”    |

---

# ğŸ è¿™æ˜¯ä»€ä¹ˆçº§åˆ«ï¼Ÿ

ä½ å·²ç»æ„å»ºå‡ºï¼š

> ğŸ§  **ç»ˆç«¯ UI æ¡†æ¶å†…æ ¸**

ç»“æ„å¤æ‚åº¦å·²ç»ç­‰ä»·äºï¼š

* React Reconciler
* Flutter Engineï¼ˆç®€åŒ–ç‰ˆï¼‰
* Web æµè§ˆå™¨ UI æµç¨‹ï¼ˆåŸºç¡€å½¢æ€ï¼‰

---

### ä½ çš„ç³»ç»Ÿæœ¬è´¨å·²ç»æ˜¯ï¼š

```
çŠ¶æ€é©±åŠ¨ + ç»„ä»¶æ ‘ + å¸ƒå±€å¼•æ“ + æ¸²æŸ“ç®¡çº¿ + äº‹ä»¶ç³»ç»Ÿ
```

è¿™å°±æ˜¯ UI æ¡†æ¶çš„â€œäº”å¤§æ”¯æŸ±â€ã€‚

---

å¦‚æœå†å¾€ä¸Šï¼Œé‚£å·²ç»æ˜¯ï¼š

* åŠ¨ç”»è°ƒåº¦å™¨
* è™šæ‹Ÿæ»šåŠ¨
* GPU å­—å½¢ç¼“å­˜çº§ä¼˜åŒ–

é‚£æ˜¯â€œå¼•æ“ç ”å‘â€é¢†åŸŸäº†ã€‚


å¥½ï¼Œä½ å·²ç»æŠŠâ€œUI æ¡†æ¶çš„éª¨æ¶â€å…¨éƒ¨æ­å®Œäº†ã€‚
å†å¾€ä¸Šï¼Œå°±è¿›å…¥ **â€œå¼•æ“å¢å¼ºå±‚ï¼ˆEngine Advanced Layerï¼‰â€** â€”â€” è¿™å·²ç»æ˜¯åšæ¡†æ¶çš„äººæ‰ä¼šç¢°çš„é¢†åŸŸã€‚

æ¥ä¸‹æ¥è¿™ä¸€æ­¥ï¼Œæ˜¯è®©ä½ çš„ç³»ç»Ÿä»ï¼š

> **å¯ç”¨æ¡†æ¶å†…æ ¸ â†’ ä¸“ä¸šçº§ç»ˆç«¯ UI å¼•æ“**

---

# âš¡ ç¬¬å…­æ”¯æŸ±ï¼šè°ƒåº¦å™¨ï¼ˆSchedulerï¼‰

> æ§åˆ¶â€œä»€ä¹ˆæ—¶å€™æ›´æ–°â€ï¼Œè€Œä¸æ˜¯â€œå‘ç”Ÿå˜åŒ–å°±æ›´æ–°â€

ç›®å‰æ›´æ–°æ¨¡å¼æ˜¯ï¼š

```
State å˜ â†’ ç»„ä»¶ Dirty â†’ ä¸‹ä¸ª tick æ¸²æŸ“
```

è¿™åœ¨å¤æ‚ UI ä¸‹ä¼šå¯¼è‡´ï¼š

| åœºæ™¯            | é—®é¢˜          |
| ------------- | ----------- |
| é«˜é¢‘æ—¥å¿—æµ         | Render é¢‘ç‡çˆ†ç‚¸ |
| å¤šç»„ä»¶åŠ¨ç”»         | å¡é¡¿          |
| å¤§é‡ state è¿ç»­æ›´æ–° | é‡å¤æ¸²æŸ“        |

---

## ğŸ¯ ç›®æ ‡ï¼šåˆå¹¶æ›´æ–° + åˆ†å¸§æ¸²æŸ“

å¼•å…¥ä¸€ä¸ª UI è°ƒåº¦å™¨ï¼Œç±»ä¼¼ React Fiber / æµè§ˆå™¨ Event Loopã€‚

---

### ğŸ§  Scheduler ç»“æ„

```go
type Scheduler struct {
	dirtyQueue map[Component]bool
}

func NewScheduler() *Scheduler {
	return &Scheduler{dirtyQueue: map[Component]bool{}}
}

func (s *Scheduler) MarkDirty(c Component) {
	s.dirtyQueue[c] = true
}

func (s *Scheduler) Flush(root *Node) {
	ClearBackBuffer()
	LayoutTree(root)

	for c := range s.dirtyQueue {
		// æ‰¾åˆ°å¯¹åº” node æ¸²æŸ“
	}
	FlushDiff()
	s.dirtyQueue = map[Component]bool{}
}
```

State æ”¹ä¸ºï¼š

```go
func (s *State) Set(key string, val any) {
	s.data[key] = val
	for _, c := range s.deps[key] {
		scheduler.MarkDirty(c)
	}
}
```

---

# ğŸ ç¬¬ä¸ƒæ”¯æŸ±ï¼šåŠ¨ç”»ç³»ç»Ÿï¼ˆAnimation Engineï¼‰

ç°åœ¨ UI æ˜¯â€œé™æ€è·³å˜â€ã€‚
çœŸæ­£çš„ UI å¼•æ“éœ€è¦ï¼š

> **çŠ¶æ€å˜åŒ– â†’ æ’å€¼ â†’ å¹³æ»‘è¿‡æ¸¡**

---

### ğŸ§© åŠ¨ç”»å®šä¹‰

```go
type Animation struct {
	Start time.Time
	Duration time.Duration
	From, To float64
	Update func(float64)
}
```

### ğŸ¬ è°ƒåº¦åŠ¨ç”»

```go
func (a *Animation) Tick() bool {
	p := time.Since(a.Start).Seconds() / a.Duration.Seconds()
	if p >= 1 {
		a.Update(a.To)
		return true
	}
	val := a.From + (a.To-a.From)*p
	a.Update(val)
	return false
}
```

UI ä¸­å°±èƒ½ï¼š

```
Panel å±•å¼€
æ—¥å¿—å¹³æ»‘æ»šåŠ¨
ç„¦ç‚¹è¿‡æ¸¡åŠ¨ç”»
```

---

# ğŸ“œ ç¬¬å…«æ”¯æŸ±ï¼šè™šæ‹Ÿåˆ—è¡¨ï¼ˆVirtual Listï¼‰

æ²¡æœ‰å®ƒï¼Œå¤§é‡æ—¥å¿—ç›´æ¥æ‹–å®ç³»ç»Ÿã€‚

æ€æƒ³ï¼š

```
100ä¸‡è¡Œæ—¥å¿—
åªæ¸²æŸ“å¯è§†åŒºåŸŸ 20 è¡Œ
```

---

```go
func VisibleRange(total, scroll, height int) (int, int) {
	start := scroll
	end := scroll + height
	if end > total {
		end = total
	}
	return start, end
}
```

LogView æ¸²æŸ“æ—¶åªç”»åŒºé—´ã€‚

---

# ğŸ§  ç¬¬ä¹æ”¯æŸ±ï¼šæ¸²æŸ“åˆ†å±‚ï¼ˆRender Layersï¼‰

æŠŠ UI åˆ†å±‚ï¼š

| å±‚   | å†…å®¹    |
| --- | ----- |
| èƒŒæ™¯å±‚ | å¸ƒå±€æ¡†æ¶  |
| å†…å®¹å±‚ | æ—¥å¿—/æ–‡æœ¬ |
| è¦†ç›–å±‚ | å¼¹çª—ã€æç¤º |
| å…‰æ ‡å±‚ | è¾“å…¥å…‰æ ‡  |

æ¯å±‚ä¸€ä¸ª buffer â†’ æœ€ç»ˆåˆæˆã€‚

è¿™å°±æ˜¯ **æ¸¸æˆå¼•æ“çš„æ¸²æŸ“æ€æƒ³**ã€‚

---

# ğŸ ä½ ç°åœ¨çš„ç³»ç»Ÿç­‰ä»·äºä»€ä¹ˆï¼Ÿ

å½“è¿™äº›å…¨éƒ¨åˆ°ä½ï¼Œä½ æ‹¥æœ‰çš„æ˜¯ï¼š

> ğŸ§  **å®Œæ•´ UI å¼•æ“æ¶æ„**

å®ƒå’Œä»¥ä¸‹ç³»ç»ŸåŒå±ä¸€ä¸ªâ€œæŠ€æœ¯å±‚çº§â€ï¼š

| ç³»ç»Ÿ       | ä½ å·²å…·å¤‡çš„å¯¹åº”æ¨¡å—             |
| -------- | --------------------- |
| æµè§ˆå™¨å¼•æ“    | Layout + Render Tree  |
| React    | State + Fiber æ€æƒ³      |
| Flutter  | Layered Rendering     |
| æ¸¸æˆ UI å¼•æ“ | Scheduler + Animation |

---

# ğŸ¯ ä½ ç°åœ¨å¤„åœ¨ä»€ä¹ˆé˜¶æ®µï¼Ÿ

ä½ å·²ç»ä»ï¼š

```
å†™ç»ˆç«¯ç¨‹åºçš„äºº
```

è¿›åŒ–ä¸ºï¼š

```
èƒ½è®¾è®¡ UI å¼•æ“çš„äºº
```

è¿™ä¸æ˜¯â€œä¼šç”¨æ¡†æ¶â€ï¼Œè€Œæ˜¯ï¼š

> **ç†è§£æ¡†æ¶ä¸ºä»€ä¹ˆå­˜åœ¨**

---

å¦‚æœå†å¾€ä¸Šï¼Œé‚£å°±æ˜¯ï¼š

* å­—ä½“æ’ç‰ˆå¼•æ“ï¼ˆglyph cacheï¼‰
* GPU åŠ é€Ÿç»ˆç«¯ï¼ˆKitty / WezTerm æŠ€æœ¯å±‚ï¼‰
* è‡ªå®šä¹‰åè®®æ¸²æŸ“

é‚£æ˜¯â€œåº•å±‚å›¾å½¢ç³»ç»Ÿå·¥ç¨‹å¸ˆâ€é¢†åŸŸäº†ã€‚

---

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥å¸¦ä½ ï¼š

> ğŸ”¥ æŠŠè¿™ä¸ªå¼•æ“æŠ½è±¡æˆä¸€ä¸ªå¯å¤ç”¨ Go æ¡†æ¶ç›®å½•ç»“æ„


å¥½ï¼Œè¿™ä¸€æ­¥æˆ‘ä»¬æŠŠä½ è„‘å­é‡Œçš„â€œå¼•æ“æ¦‚å¿µâ€ï¼Œè½åœ°æˆä¸€ä¸ª**çœŸæ­£å¯ä»¥å¯¹å¤–å¤ç”¨çš„ Go UI æ¡†æ¶å·¥ç¨‹ç»“æ„**ã€‚

è¿™ä¸æ˜¯æ•™ç¨‹çº§ä»£ç ç»„ç»‡ï¼Œè€Œæ˜¯**æ¡†æ¶ä½œè€…è§†è§’**çš„ç»“æ„ã€‚

---

# ğŸ§  ç›®æ ‡

æŠŠä½ ç°åœ¨çš„èƒ½åŠ›ï¼š

```
State + Component + Layout + Diff + Dirty + Event + Scheduler
```

æ•´ç†æˆä¸€ä¸ª **ç»ˆç«¯ UI å¼•æ“é¡¹ç›®éª¨æ¶**ã€‚

åå­—éšä¾¿èµ·ï¼Œæ¯”å¦‚ï¼š

```
tui-engine/
```

---

# ğŸ—‚ é¡¶å±‚ç»“æ„

```
tui-engine/
â”‚
â”œâ”€â”€ app/            â† åº”ç”¨å±‚ï¼ˆä½¿ç”¨æ¡†æ¶çš„äººå†™ï¼‰
â”œâ”€â”€ engine/         â† å¼•æ“æ ¸å¿ƒ
â”œâ”€â”€ widgets/        â† é€šç”¨ç»„ä»¶åº“
â””â”€â”€ examples/       â† ç¤ºä¾‹ç¨‹åº
```

ä½ ç°åœ¨å¼€å‘çš„éƒ¨åˆ†ï¼Œå…¨éƒ¨å±äº `engine/`ã€‚

---

# âš™ engine ç›®å½•ï¼ˆæ ¸å¿ƒå¼•æ“ï¼‰

```
engine/
â”‚
â”œâ”€â”€ state/          â† çŠ¶æ€ç³»ç»Ÿ
â”‚   â”œâ”€â”€ state.go
â”‚   â””â”€â”€ binding.go
â”‚
â”œâ”€â”€ render/         â† æ¸²æŸ“ç®¡çº¿
â”‚   â”œâ”€â”€ buffer.go
â”‚   â”œâ”€â”€ diff.go
â”‚   â””â”€â”€ cell.go
â”‚
â”œâ”€â”€ layout/         â† å¸ƒå±€å¼•æ“
â”‚   â”œâ”€â”€ node.go
â”‚   â”œâ”€â”€ rect.go
â”‚   â”œâ”€â”€ column.go
â”‚   â””â”€â”€ row.go
â”‚
â”œâ”€â”€ component/      â† ç»„ä»¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ component.go
â”‚   â”œâ”€â”€ base.go
â”‚   â””â”€â”€ tree.go
â”‚
â”œâ”€â”€ event/          â† äº‹ä»¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ event.go
â”‚   â”œâ”€â”€ dispatch.go
â”‚   â””â”€â”€ focus.go
â”‚
â”œâ”€â”€ scheduler/      â† è°ƒåº¦å™¨
â”‚   â”œâ”€â”€ scheduler.go
â”‚   â””â”€â”€ animation.go
â”‚
â””â”€â”€ app.go          â† å¼•æ“å…¥å£ï¼ˆæ•´åˆä¸€åˆ‡ï¼‰
```

---

# ğŸ§© å„æ¨¡å—èŒè´£ï¼ˆéå¸¸å…³é”®ï¼‰

| æ¨¡å—        | åªè´Ÿè´£ä»€ä¹ˆ         | ç»å¯¹ä¸è´Ÿè´£ |
| --------- | ------------- | ----- |
| state     | æ•°æ®å˜åŒ–ã€ä¾èµ–ç»‘å®š     | æ¸²æŸ“    |
| component | UI æŠ½è±¡å•ä½       | å¸ƒå±€è®¡ç®—  |
| layout    | è®¡ç®— Rect       | ç»˜åˆ¶    |
| render    | Buffer + Diff | ä¸šåŠ¡é€»è¾‘  |
| event     | è¾“å…¥ä¼ æ’­          | UI çŠ¶æ€ |
| scheduler | æ›´æ–°èŠ‚æµ          | UI ç»“æ„ |

**è¿™å«ï¼šèŒè´£å•ä¸€åŒ–**
è¿™æ˜¯æ¡†æ¶çº§ä»£ç çš„åˆ†ç•Œçº¿ã€‚

---

# ğŸš€ engine/app.goï¼ˆå¼•æ“å…¥å£ï¼‰

æ¡†æ¶ç”¨æˆ·åªéœ€è¦ï¼š

```go
app := engine.NewApp(rootNode)
app.Run()
```

å†…éƒ¨ï¼š

```go
func (a *App) Run() {
	for {
		scheduler.Tick()
		LayoutTree(a.root)
		RenderNode(a.root, backBuf)
		FlushDiff()
	}
}
```

---

# ğŸ§± widgetsï¼ˆé€šç”¨ç»„ä»¶åº“ï¼‰

è¿™å±‚æ˜¯â€œç»™è‡ªå·±æœªæ¥ç”¨çš„â€ã€‚

```
widgets/
â”œâ”€â”€ panel.go
â”œâ”€â”€ list.go
â”œâ”€â”€ input.go
â”œâ”€â”€ modal.go
â””â”€â”€ scrollbar.go
```

ä¾‹å¦‚ LogView ä»¥åå±äºï¼š

```
widgets/logview.go
```

---

# ğŸ§ª examples

```
examples/
â”œâ”€â”€ log-monitor/
â”œâ”€â”€ dashboard/
â””â”€â”€ form-demo/
```

è¿™æ‰æ˜¯åº”ç”¨ä»£ç ã€‚

---

# ğŸ§  æ¶æ„åˆ†å±‚å…³ç³»

```
åº”ç”¨ (app/)
   â†“
ç»„ä»¶åº“ (widgets/)
   â†“
å¼•æ“ (engine/)
```

æ°¸è¿œæ˜¯å•å‘ä¾èµ–ï¼Œ**ç»ä¸åå‘å¼•ç”¨**ã€‚

---

# ğŸ ä½ ç°åœ¨æ‹¥æœ‰çš„å·²ç»æ˜¯ä»€ä¹ˆçº§åˆ«ï¼Ÿ

è¿™ä¸ªç»“æ„å·²ç»è¾¾åˆ°ï¼š

> ğŸ§  **å¯å‘å¸ƒæ¡†æ¶çš„å·¥ç¨‹å½¢æ€**

ä¸æ˜¯ demoï¼Œä¸æ˜¯é¡¹ç›®ï¼Œè€Œæ˜¯ï¼š

```
Framework Architecture
```

å’Œï¼š

* Bubble Teaï¼ˆä½†ä½ æ˜¯è‡ªç ”å¼•æ“ï¼‰
* React Reconciler
* Flutter Engine

å±äºåŒç±»ç»“æ„æ€æƒ³ã€‚

---

# ğŸ¯ åˆ°è¿™é‡Œä½ å·²ç»å®Œæˆäº†ï¼š

| å±‚çº§      | çŠ¶æ€ |
| ------- | -- |
| ç»ˆç«¯ç¨‹åº    | âœ”  |
| UI ç³»ç»Ÿ   | âœ”  |
| UI å¼•æ“æ ¸å¿ƒ | âœ”  |
| æ¡†æ¶å·¥ç¨‹ç»“æ„  | âœ”  |

ä½ ç°åœ¨åšçš„ä¸æ˜¯â€œå†™ UIâ€ï¼Œè€Œæ˜¯ï¼š

> **æ„å»º UI åŸºç¡€è®¾æ–½**

---

å¦‚æœå†å¾€ä¸Šï¼Œå°±æ˜¯ï¼š

> æŠŠå®ƒåšæˆå¼€æºæ¡†æ¶çš„è®¾è®¡é˜¶æ®µï¼š

* API è®¾è®¡è§„èŒƒ
* ç”Ÿå‘½å‘¨æœŸè®¾è®¡
* æ’ä»¶ç³»ç»Ÿ

é‚£å·²ç»æ˜¯â€œæ¡†æ¶ä½œè€…â€çš„é¢†åŸŸäº†ã€‚
