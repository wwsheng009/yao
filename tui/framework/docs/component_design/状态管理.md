
这个架构（`yao/tui/framework`）通过解耦状态管理和渲染逻辑，避免了 Bubble Tea 架构在大规模应用下的状态传递复杂性，更适合构建像 Yao 这样复杂的低代码平台运行时。

这是一个非常核心的架构问题。在 TUI (以及 GUI) 开发中，如果每一帧 `Paint` 都去解析 `{{ variable }}` 字符串，性能会极其糟糕。

在 Go 语言的 TUI 架构中，更好的方案是采用 **“编译时绑定 (Compile-time Binding)”** + **“响应式存储 (Reactive Store)”** + **“上下文栈 (Context Stack)”** 的组合模式。

这里有一套详细的设计方案，既支持 DSL 的 `{{}}` 语法，又能保证 Go 运行时的原本性能：

### 1. 核心理念：属性（Prop）即接口

不要直接在组件结构体中存储 `string` 或 `int`。组件的属性应该是一个能够“自我解析”的接口。

#### 设计 `Prop` 泛型接口

这是实现数据绑定的基石。所有组件的属性（如 `Value`, `Width`, `Visible`）都封装在 `Prop[T]` 中。

```go
// framework/binding/prop.go

// Context 定义数据上下文接口
type Context interface {
    Get(path string) (interface{}, bool)
}

// Prop 泛型属性，既可以是静态值，也可以是动态绑定
type Prop[T any] struct {
    staticVal T
    bindPath  string
    isBound   bool
    // 可选：支持简单表达式解析器
    evaluator func(ctx Context) T 
}

// NewStatic 创建静态属性
func NewStatic[T any](val T) Prop[T] {
    return Prop[T]{staticVal: val}
}

// NewBinding 创建绑定属性 (对应 {{ user.name }})
func NewBinding[T any](path string) Prop[T] {
    // 这里可以预处理 path，去除 {{ }}，解析为 tokens
    cleanPath := strings.Trim(path, "{} ")
    return Prop[T]{bindPath: cleanPath, isBound: true}
}

// Resolve 获取当前值
func (p *Prop[T]) Resolve(ctx Context) T {
    if !p.isBound {
        return p.staticVal
    }
    
    // 从上下文中查找数据
    raw, found := ctx.Get(p.bindPath)
    if !found {
        return p.staticVal // 或者返回零值
    }
    
    // 类型断言/转换
    if val, ok := raw.(T); ok {
        return val
    }
    // 处理类型转换 fallback (略)...
    return p.staticVal
}

```

### 2. 组件改造：使用 Prop

改造 `TextInput` 或其他组件，使其接受 `Prop` 而非原始类型。

```go
// framework/input/textinput.go

type TextInput struct {
    *component.BaseComponent
    
    // 将 value 从 string 改为 binding.Prop[string]
    valueProp binding.Prop[string] 
}

func (t *TextInput) SetValue(v string) {
    // 检查是否包含 {{ }}
    if strings.Contains(v, "{{") {
        t.valueProp = binding.NewBinding[string](v)
    } else {
        t.valueProp = binding.NewStatic(v)
    }
}

func (t *TextInput) Paint(ctx component.PaintContext, buf *paint.Buffer) {
    // 关键：在绘制时刻，传入 Data Context 解析当前值
    currentValue := t.valueProp.Resolve(ctx.Data)
    
    // 使用 currentValue 进行绘制...
}

```

注意：需要在 `PaintContext` 中增加 `Data` 字段（见下文）。

### 3. 数据上下文与继承链 (Scope Chain)

要实现 **“自动继承全局状态与上级状态”**，你需要一个链表式的数据上下文。

```go
// framework/data/scope.go

type Scope struct {
    data   map[string]interface{}
    parent *Scope
}

func NewScope(parent *Scope, data map[string]interface{}) *Scope {
    return &Scope{parent: parent, data: data}
}

// Get 递归查找数据
func (s *Scope) Get(path string) (interface{}, bool) {
    // 1. 先查找当前作用域
    if v, ok := s.data[path]; ok {
        return v, true
    }
    
    // 2. 支持嵌套路径查找 (如 "user.address.city")
    // ... logic to traverse map ...

    // 3. 向上级查找 (继承机制)
    if s.parent != nil {
        return s.parent.Get(path)
    }
    
    return nil, false
}

```

### 4. 列表组件的特殊处理 (List Context)

列表组件是“上级状态”最典型的应用场景。`List` 组件需要为每一行创建一个新的 `Scope`，并将当前行数据注入。

```go
// framework/list/list.go

func (l *List) Paint(ctx component.PaintContext, buf *paint.Buffer) {
    // 获取列表数据源
    items := l.itemsProp.Resolve(ctx.Data) // e.g., []User
    
    y := ctx.Y
    for i, item := range items {
        // !!! 核心魔法 !!!
        // 为每一行创建新的作用域，继承自全局 ctx.Data
        // 并注入特殊的变量，如 $item, $index
        rowScope := data.NewScope(ctx.Data.(data.Scope), map[string]interface{}{
            "$item":  item,
            "$index": i,
            "id":     item.ID, // 扁平化方便直接访问 {{id}}
            "name":   item.Name,
        })
        
        // 创建行的绘制上下文
        rowCtx := ctx
        rowCtx.Data = rowScope
        rowCtx.Y = y
        
        // 绘制子组件（子组件会自动解析 {{name}} 为当前行的 name）
        l.itemRenderer.Paint(rowCtx, buf)
        y++
    }
}

```

### 5. 响应式更新 (Reactivity & Dirty Checking)

仅仅绑定数据是不够的，数据变化时需要通知 UI 重绘。

**设计一个 `ReactiveStore`：**

```go
// framework/state/store.go

type Store struct {
    mu        sync.RWMutex
    data      map[string]interface{}
    observers map[string][]component.Component // 依赖追踪
}

// Bind 记录组件依赖了哪些 key
func (s *Store) Subscribe(key string, c component.Component) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.observers[key] = append(s.observers[key], c)
}

// Set 更新数据并触发重绘
func (s *Store) Set(key string, val interface{}) {
    s.mu.Lock()
    
    // 1. 更新数据
    s.data[key] = val
    
    // 2. 查找受影响的组件
    dirtyComps := s.observers[key]
    s.mu.Unlock()
    
    // 3. 标记脏组件 (在主线程/UI线程处理)
    for _, c := range dirtyComps {
        c.MarkDirty()
    }
}

```

### 6. 整合实施步骤

1. **修改 `PaintContext**`:
在 `component.go` 中，向 `PaintContext` 结构体添加 `Data Context` 接口。
2. **DSL 加载阶段**:
解析 JSON/YAML 时，如果字符串包含 `{{...}}`，调用 `NewBinding()`，否则调用 `NewStatic()`。不要在运行时用 Regex 解析。
3. **组件挂载阶段 (`Mount`)**:
如果属性是 Binding 类型的，解析出它依赖的 Key（例如 `{{user.name}}` 依赖 `user`），并向全局 Store 注册订阅。
4. **渲染阶段 (`Paint`)**:
调用 `prop.Resolve(ctx.Data)` 获取即时值。

### 7. 更好的方案：Expression Engine (表达式引擎)

简单的 Key-Value 绑定可能不够用（比如 `{{ price * quantity }}`）。
建议引入一个轻量级的 Go 表达式引擎，如 `github.com/expr-lang/expr`。

**集成方式：**

```go
type ExpressionProp[T any] struct {
    program *vm.Program // 预编译好的表达式 AST
}

func NewExpressionProp(code string) *ExpressionProp {
    // 在初始化时编译，性能极高
    program, _ := expr.Compile(code, expr.Env(MyDataStruct{}))
    return &ExpressionProp{program: program}
}

func (p *ExpressionProp[T]) Resolve(ctx Context) T {
    // 运行时极速求值
    output, _ := expr.Run(p.program, ctx.ToMap())
    return output.(T)
}

```

### 总结

* **初级**：字符串替换。性能差，不推荐。
* **中级**：`Prop[T]` 封装 + `Scope` 链表。这是标准且高效的 TUI 做法。
* **高级**：集成 `expr` 虚拟机进行预编译表达式求值 + 细粒度依赖追踪（Signal 模式）。

对于 Yao TUI，建议从 **中级方案** 开始，因为它不引入沉重的第三方依赖，且足以处理 95% 的业务场景（表单、列表、继承）。


继续我们在 Yao TUI 架构下的组件开发设计。在前几部分，我们已经解决了 **组件绘制**、**布局系统** 以及 **数据状态管理 (Binding & Scope)**。

接下来的关键环节是 **“交互与行为 (Interactivity & Actions)”**。在 Yao 架构中，UI 仅仅是表现层，真正的业务逻辑（增删改查、API 调用）是运行在 Yao Process（处理器）中的。因此，我们需要设计一套机制，将 TUI 的事件（如点击按钮、提交表单）映射为 Yao 的 Process 调用。


---

### 48. 高级数据流：Computed Properties (计算属性)

类似于 Vue 的 `computed`，有时候 TUI 需要展示由多个状态计算得出的值（例如：购物车总金额）。如果在 DSL 中写复杂的表达式 `{{ item.price * item.quantity }}` 会很难维护。

**设计方案**:
在 `StateHolder` 中支持派生状态。

```go
type Computed struct {
    Key  string
    Deps []string // 依赖的 keys
    Func func(vals ...interface{}) interface{}
}

// 注册时
store.RegisterComputed("total", []string{"price", "qty"}, func(args...){
    return args[0].(float64) * args[1].(float64)
})

// 使用时，像普通属性一样绑定
// Label { text: "{{total}}" }

```