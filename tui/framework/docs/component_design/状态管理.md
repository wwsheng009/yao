
这个架构（`yao/tui/framework`）通过解耦状态管理和渲染逻辑，避免了 Bubble Tea 架构在大规模应用下的状态传递复杂性，更适合构建像 Yao 这样复杂的低代码平台运行时。

这是一个非常核心的架构问题。在 TUI (以及 GUI) 开发中，如果每一帧 `Paint` 都去解析 `{{ variable }}` 字符串，性能会极其糟糕。

在 Go 语言的 TUI 架构中，更好的方案是采用 **“编译时绑定 (Compile-time Binding)”** + **“响应式存储 (Reactive Store)”** + **“上下文栈 (Context Stack)”** 的组合模式。

这里有一套详细的设计方案，既支持 DSL 的 `{{}}` 语法，又能保证 Go 运行时的原本性能：

### 1. 核心理念：属性（Prop）即接口

不要直接在组件结构体中存储 `string` 或 `int`。组件的属性应该是一个能够“自我解析”的接口。

#### 设计 `Prop` 泛型接口

这是实现数据绑定的基石。所有组件的属性（如 `Value`, `Width`, `Visible`）都封装在 `Prop[T]` 中。

```go
// framework/binding/prop.go

// Context 定义数据上下文接口
type Context interface {
    Get(path string) (interface{}, bool)
}

// Prop 泛型属性，既可以是静态值，也可以是动态绑定
type Prop[T any] struct {
    staticVal T
    bindPath  string
    isBound   bool
    // 可选：支持简单表达式解析器
    evaluator func(ctx Context) T 
}

// NewStatic 创建静态属性
func NewStatic[T any](val T) Prop[T] {
    return Prop[T]{staticVal: val}
}

// NewBinding 创建绑定属性 (对应 {{ user.name }})
func NewBinding[T any](path string) Prop[T] {
    // 这里可以预处理 path，去除 {{ }}，解析为 tokens
    cleanPath := strings.Trim(path, "{} ")
    return Prop[T]{bindPath: cleanPath, isBound: true}
}

// Resolve 获取当前值
func (p *Prop[T]) Resolve(ctx Context) T {
    if !p.isBound {
        return p.staticVal
    }
    
    // 从上下文中查找数据
    raw, found := ctx.Get(p.bindPath)
    if !found {
        return p.staticVal // 或者返回零值
    }
    
    // 类型断言/转换
    if val, ok := raw.(T); ok {
        return val
    }
    // 处理类型转换 fallback (略)...
    return p.staticVal
}

```

### 2. 组件改造：使用 Prop

改造 `TextInput` 或其他组件，使其接受 `Prop` 而非原始类型。

```go
// framework/input/textinput.go

type TextInput struct {
    *component.BaseComponent
    
    // 将 value 从 string 改为 binding.Prop[string]
    valueProp binding.Prop[string] 
}

func (t *TextInput) SetValue(v string) {
    // 检查是否包含 {{ }}
    if strings.Contains(v, "{{") {
        t.valueProp = binding.NewBinding[string](v)
    } else {
        t.valueProp = binding.NewStatic(v)
    }
}

func (t *TextInput) Paint(ctx component.PaintContext, buf *paint.Buffer) {
    // 关键：在绘制时刻，传入 Data Context 解析当前值
    currentValue := t.valueProp.Resolve(ctx.Data)
    
    // 使用 currentValue 进行绘制...
}

```

注意：需要在 `PaintContext` 中增加 `Data` 字段（见下文）。

### 3. 数据上下文与继承链 (Scope Chain)

要实现 **“自动继承全局状态与上级状态”**，你需要一个链表式的数据上下文。

```go
// framework/data/scope.go

type Scope struct {
    data   map[string]interface{}
    parent *Scope
}

func NewScope(parent *Scope, data map[string]interface{}) *Scope {
    return &Scope{parent: parent, data: data}
}

// Get 递归查找数据
func (s *Scope) Get(path string) (interface{}, bool) {
    // 1. 先查找当前作用域
    if v, ok := s.data[path]; ok {
        return v, true
    }
    
    // 2. 支持嵌套路径查找 (如 "user.address.city")
    // ... logic to traverse map ...

    // 3. 向上级查找 (继承机制)
    if s.parent != nil {
        return s.parent.Get(path)
    }
    
    return nil, false
}

```

### 4. 列表组件的特殊处理 (List Context)

列表组件是“上级状态”最典型的应用场景。`List` 组件需要为每一行创建一个新的 `Scope`，并将当前行数据注入。

```go
// framework/list/list.go

func (l *List) Paint(ctx component.PaintContext, buf *paint.Buffer) {
    // 获取列表数据源
    items := l.itemsProp.Resolve(ctx.Data) // e.g., []User
    
    y := ctx.Y
    for i, item := range items {
        // !!! 核心魔法 !!!
        // 为每一行创建新的作用域，继承自全局 ctx.Data
        // 并注入特殊的变量，如 $item, $index
        rowScope := data.NewScope(ctx.Data.(data.Scope), map[string]interface{}{
            "$item":  item,
            "$index": i,
            "id":     item.ID, // 扁平化方便直接访问 {{id}}
            "name":   item.Name,
        })
        
        // 创建行的绘制上下文
        rowCtx := ctx
        rowCtx.Data = rowScope
        rowCtx.Y = y
        
        // 绘制子组件（子组件会自动解析 {{name}} 为当前行的 name）
        l.itemRenderer.Paint(rowCtx, buf)
        y++
    }
}

```

### 5. 响应式更新 (Reactivity & Dirty Checking)

仅仅绑定数据是不够的，数据变化时需要通知 UI 重绘。

**设计一个 `ReactiveStore`：**

```go
// framework/state/store.go

type Store struct {
    mu        sync.RWMutex
    data      map[string]interface{}
    observers map[string][]component.Component // 依赖追踪
}

// Bind 记录组件依赖了哪些 key
func (s *Store) Subscribe(key string, c component.Component) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.observers[key] = append(s.observers[key], c)
}

// Set 更新数据并触发重绘
func (s *Store) Set(key string, val interface{}) {
    s.mu.Lock()
    
    // 1. 更新数据
    s.data[key] = val
    
    // 2. 查找受影响的组件
    dirtyComps := s.observers[key]
    s.mu.Unlock()
    
    // 3. 标记脏组件 (在主线程/UI线程处理)
    for _, c := range dirtyComps {
        c.MarkDirty()
    }
}

```

### 6. 整合实施步骤

1. **修改 `PaintContext**`:
在 `component.go` 中，向 `PaintContext` 结构体添加 `Data Context` 接口。
2. **DSL 加载阶段**:
解析 JSON/YAML 时，如果字符串包含 `{{...}}`，调用 `NewBinding()`，否则调用 `NewStatic()`。不要在运行时用 Regex 解析。
3. **组件挂载阶段 (`Mount`)**:
如果属性是 Binding 类型的，解析出它依赖的 Key（例如 `{{user.name}}` 依赖 `user`），并向全局 Store 注册订阅。
4. **渲染阶段 (`Paint`)**:
调用 `prop.Resolve(ctx.Data)` 获取即时值。

### 7. 更好的方案：Expression Engine (表达式引擎)

简单的 Key-Value 绑定可能不够用（比如 `{{ price * quantity }}`）。
建议引入一个轻量级的 Go 表达式引擎，如 `github.com/expr-lang/expr`。

**集成方式：**

```go
type ExpressionProp[T any] struct {
    program *vm.Program // 预编译好的表达式 AST
}

func NewExpressionProp(code string) *ExpressionProp {
    // 在初始化时编译，性能极高
    program, _ := expr.Compile(code, expr.Env(MyDataStruct{}))
    return &ExpressionProp{program: program}
}

func (p *ExpressionProp[T]) Resolve(ctx Context) T {
    // 运行时极速求值
    output, _ := expr.Run(p.program, ctx.ToMap())
    return output.(T)
}

```

### 总结

* **初级**：字符串替换。性能差，不推荐。
* **中级**：`Prop[T]` 封装 + `Scope` 链表。这是标准且高效的 TUI 做法。
* **高级**：集成 `expr` 虚拟机进行预编译表达式求值 + 细粒度依赖追踪（Signal 模式）。

对于 Yao TUI，建议从 **中级方案** 开始，因为它不引入沉重的第三方依赖，且足以处理 95% 的业务场景（表单、列表、继承）。


继续我们在 Yao TUI 架构下的组件开发设计。在前几部分，我们已经解决了 **组件绘制**、**布局系统** 以及 **数据状态管理 (Binding & Scope)**。

接下来的关键环节是 **“交互与行为 (Interactivity & Actions)”**。在 Yao 架构中，UI 仅仅是表现层，真正的业务逻辑（增删改查、API 调用）是运行在 Yao Process（处理器）中的。因此，我们需要设计一套机制，将 TUI 的事件（如点击按钮、提交表单）映射为 Yao 的 Process 调用。


---

### 48. 高级数据流：Computed Properties (计算属性)

类似于 Vue 的 `computed`，有时候 TUI 需要展示由多个状态计算得出的值（例如：购物车总金额）。如果在 DSL 中写复杂的表达式 `{{ item.price * item.quantity }}` 会很难维护。

**设计方案**:
在 `StateHolder` 中支持派生状态。

```go
type Computed struct {
    Key  string
    Deps []string // 依赖的 keys
    Func func(vals ...interface{}) interface{}
}

// 注册时
store.RegisterComputed("total", []string{"price", "qty"}, func(args...){
    return args[0].(float64) * args[1].(float64)
})

// 使用时，像普通属性一样绑定
// Label { text: "{{total}}" }

```

---

## 架构实现分析

### 一、设计文档 vs 实际实现对比

#### 1. 文档中的设计方案

本文档提出的**响应式数据绑定**架构：

| 特性 | 设计方案 |
|------|----------|
| **Prop 泛型属性** | `Prop[T]` 支持静态值和动态绑定 `{{ variable }}` |
| **Scope 链** | 链表式数据上下文，支持状态继承 |
| **响应式 Store** | `ReactiveStore` 支持依赖追踪和订阅通知 |
| **表达式引擎** | 预编译表达式求值 |
| **列表上下文** | 为每行创建独立 Scope |

#### 2. 实际实现的架构

当前实现采用不同的设计路径：**快照式状态追踪** + **组件本地状态** + **集中式 Runtime**

```
┌─────────────────────────────────────────────────────────────────┐
│                        tui/runtime                               │
├─────────────────────────────────────────────────────────────────┤
│  state.Tracker          │  core.Runtime                        │
│  ├── current *Snapshot  │  ├── stateTracker *Tracker           │
│  ├── past []*Snapshot   │  ├── focusManager *ManagerV3          │
│  ├── future []*Snapshot │  ├── actionDispatcher *Dispatcher     │
│  └── listeners []func   │  └── dirtyTracker *DirtyTracker       │
├─────────────────────────────────────────────────────────────────┤
│  state.Snapshot                                                 │
│  ├── FocusPath []string      (焦点路径)                         │
│  ├── Components map[string]ComponentState                       │
│  ├── Modals []ModalState     (模态框栈)                         │
│  └── Dirty DirtyRegion       (脏区域)                           │
├─────────────────────────────────────────────────────────────────┤
│                        tui/framework                             │
├─────────────────────────────────────────────────────────────────┤
│  component.StateHolder                                        │
│  ├── state map[string]interface  (组件本地状态)                 │
│  └── props map[string]interface  (组件属性)                     │
│                                                                  │
│  component.ComponentContext                                     │
│  └── dirtyCallback func()        (脏标记回调)                    │
└─────────────────────────────────────────────────────────────────┘
```

### 二、状态管理模块详解

#### 1. Framework 层状态管理 (`tui/framework/component/`)

**StateHolder** - 组件本地状态持有者：
```go
// tui/framework/component/state_holder.go:14-19
type StateHolder struct {
    mu    sync.RWMutex
    state map[string]interface{}  // 动态状态
    props map[string]interface{}  // 静态属性
}
```

**ComponentContext** - 组件运行时上下文：
```go
// tui/framework/component/context.go:7-10
type ComponentContext struct {
    dirtyCallback func()  // 脏标记回调
}
```

#### 2. Runtime 层状态管理 (`tui/runtime/state/`)

**Tracker** - 核心状态追踪器：
```go
// tui/runtime/state/tracker.go:12-30
type Tracker struct {
    mu         sync.RWMutex
    current    *Snapshot           // 当前快照
    past       []*Snapshot         // 历史栈
    future     []*Snapshot         // 重做栈
    maxHistory int                 // 最大历史数
    listeners  []ChangeListener    // 变化监听器
}
```

核心能力：
- **Undo/Redo**: 时间旅行式状态回溯
- **变化订阅**: `Subscribe(listener)` 监听状态变化
- **快照隔离**: 每次操作前后记录状态

**Snapshot** - 状态快照：
```go
// tui/runtime/state/snapshot.go:13-33
type Snapshot struct {
    Timestamp  time.Time
    FocusPath  FocusPath                    // 焦点路径
    Components map[string]ComponentState     // 所有组件状态
    Modals     []ModalState                 // 模态框栈
    Dirty      DirtyRegion                  // 脏区域
    Metadata   map[string]interface{}       // 元数据
}
```

#### 3. Core Runtime 集成 (`tui/runtime/core/`)

**Runtime** 核心引擎整合所有子系统：
```go
// tui/runtime/core/runtime.go:22-46
type Runtime struct {
    mu                sync.RWMutex
    platform          platform.RuntimePlatform
    layoutEngine      *layout.Engine
    focusManager      *focus.ManagerV3
    stateTracker      *state.Tracker         // 状态追踪
    actionDispatcher  *action.Dispatcher     // 动作分发
    keyMap            *input.KeyMap
    contextManager    *ContextManager        // 上下文管理
    root              layout.Node
    buffer            *paint.Buffer
    dirtyTracker      *paint.DirtyTracker
}
```

### 三、设计模式分析

| 模式 | 应用位置 | 说明 |
|------|----------|------|
| **Memento** | `state.Tracker` + `Snapshot` | 快照式状态存储，支持 Undo |
| **Observer** | `Tracker.listeners` | 状态变化订阅通知 |
| **Strategy** | `ComponentState.State/Props` | 状态与属性分离存储策略 |
| **Command** | `action.Action` + `Tracker` | 封装操作，支持撤销 |
| **Context Object** | `ComponentContext` | 传递运行时依赖 |

### 四、与文档方案的差异

| 方面 | 文档设计 | 实际实现 | 评价 |
|------|----------|----------|------|
| **数据绑定** | `Prop[T]` 动态解析 | 直接存储值 | 实现更简单，性能更好 |
| **状态继承** | Scope 链式查找 | 无全局 Scope | 组件间状态隔离更好 |
| **响应式** | 细粒度依赖追踪 | 脏标记全局重绘 | 牺牲性能换取简单性 |
| **时间旅行** | 未涉及 | 完整 Undo/Redo | 实际实现更强 |
| **表达式** | 预编译表达式 | 无 DSL 表达式 | 未实现 DSL 层 |

### 五、总结

当前 Yao TUI 的状态管理采用了**快照式架构**而非文档中的**响应式绑定架构**：

**优点**：
1. 完整的 Undo/Redo 时间旅行能力
2. 状态序列化持久化支持
3. 线程安全设计
4. 与 Bubble Tea 解耦的纯布局核心

**与文档的差异**：
1. 未实现 `Prop[T]` 动态绑定机制
2. 无 Scope 链式状态继承
3. 无细粒度响应式更新

---

## DSL 层实现 (2025-01)

为实现文档设计的响应式数据绑定，新增 `tui/framework/binding` 包：

### 实现模块

1. **`binding/prop.go`** - `Prop[T]` 泛型属性接口
2. **`binding/context.go`** - 数据上下文接口
3. **`binding/scope.go`** - Scope 链式上下文系统
4. **`binding/expression.go`** - 表达式解析器
5. **`binding/store.go`** - 响应式存储

详见：`tui/framework/binding/`