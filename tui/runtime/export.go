// Package runtime provides export functionality for rendered frames.
//
// This file implements file export in multiple formats:
// - TXT: Plain text output
// - SVG: Scalable Vector Graphics with styling
// - PNG: Raster image with bitmap font rendering
package runtime

import (
	"bytes"
	"compress/flate"
	"encoding/base64"
	"fmt"
	"hash/crc32"
	"os"
	"strings"
)

// ExportFormat represents the output format for export.
type ExportFormat string

const (
	FormatTXT ExportFormat = "txt"
	FormatSVG ExportFormat = "svg"
	FormatPNG ExportFormat = "png"
)

// Exporter handles exporting frames to various formats.
type Exporter struct {
	frame        *Frame
	layoutResult *LayoutResult
	// Color scheme for PNG/SVG export
	colorScheme  ColorScheme
}

// ColorScheme defines colors for export rendering.
type ColorScheme struct {
	Background RGBA
	Foreground RGBA
	Bold       RGBA
	Underline  RGBA
	Italic     RGBA
	Border     RGBA
}

// RGBA represents a 32-bit color with alpha.
type RGBA struct {
	R, G, B, A uint8
}

// DefaultColorScheme returns the default color scheme.
func DefaultColorScheme() ColorScheme {
	return ColorScheme{
		Background: RGBA{0x1e, 0x1e, 0x1e, 0xff}, // Dark background
		Foreground: RGBA{0xd4, 0xd4, 0xd4, 0xff}, // Light text
		Bold:       RGBA{0xff, 0xff, 0xff, 0xff}, // White for bold
		Underline:  RGBA{0x56, 0x9c, 0xd6, 0xff}, // Blue for underline
		Italic:     RGBA{0xdc, 0xdc, 0xaa, 0xff}, // Yellow for italic
		Border:     RGBA{0x44, 0x44, 0x44, 0xff}, // Gray for borders
	}
}

// LightColorScheme returns a light color scheme.
func LightColorScheme() ColorScheme {
	return ColorScheme{
		Background: RGBA{0xff, 0xff, 0xff, 0xff}, // White background
		Foreground: RGBA{0x00, 0x00, 0x00, 0xff}, // Black text
		Bold:       RGBA{0x00, 0x00, 0x00, 0xff}, // Black for bold
		Underline:  RGBA{0x00, 0x00, 0xff, 0xff}, // Blue for underline
		Italic:     RGBA{0x80, 0x80, 0x00, 0xff}, // Yellow for italic
		Border:     RGBA{0xcc, 0xcc, 0xcc, 0xff}, // Light gray for borders
	}
}

// NewExporter creates a new Exporter for the given frame.
func NewExporter(frame *Frame, layoutResult *LayoutResult) *Exporter {
	return &Exporter{
		frame:        frame,
		layoutResult: layoutResult,
		colorScheme:  DefaultColorScheme(),
	}
}

// SetColorScheme sets the color scheme for export.
func (e *Exporter) SetColorScheme(scheme ColorScheme) {
	e.colorScheme = scheme
}

// SaveTo saves the frame to a file in the specified format.
func (e *Exporter) SaveTo(filename string, format ExportFormat) error {
	switch format {
	case FormatTXT:
		return e.SaveToTXT(filename)
	case FormatSVG:
		return e.SaveToSVG(filename)
	case FormatPNG:
		return e.SaveToPNG(filename)
	default:
		return fmt.Errorf("unsupported format: %s", format)
	}
}

// SaveToTXT saves the frame as a plain text file.
func (e *Exporter) SaveToTXT(filename string) error {
	if e.frame == nil || e.frame.Buffer == nil {
		return fmt.Errorf("no frame to export")
	}

	// Get plain text output
	debug := DebugFrame(e.frame, e.layoutResult)
	content := debug.PlainOutput()

	// Write to file
	return os.WriteFile(filename, []byte(content), 0644)
}

// SaveToSVG saves the frame as an SVG file with styling.
func (e *Exporter) SaveToSVG(filename string) error {
	if e.frame == nil || e.frame.Buffer == nil {
		return fmt.Errorf("no frame to export")
	}

	buf := e.frame.Buffer
	width := buf.Width()
	height := buf.Height()

	// Cell dimensions (in pixels)
	cellWidth := 10
	cellHeight := 18

	// SVG dimensions
	svgWidth := width * cellWidth
	svgHeight := height * cellHeight

	var sb strings.Builder

	// SVG header
	bg := e.colorScheme.Background
	fg := e.colorScheme.Foreground

	sb.WriteString(fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="%d" height="%d" viewBox="0 0 %d %d">
<style>
  .cell { font-family: "JetBrains Mono", "Fira Code", "Consolas", monospace; font-size: %dpx; }
  .bg { fill: #%02x%02x%02x; }
  .fg { fill: #%02x%02x%02x; }
  .bold { font-weight: bold; }
  .italic { font-style: italic; }
  .underline { text-decoration: underline; }
</style>
<rect width="100%%" height="100%%" class="bg"/>`,
		svgWidth, svgHeight, svgWidth, svgHeight,
		cellHeight-2,
		bg.R, bg.G, bg.B,
		fg.R, fg.G, fg.B,
	))

	// Render each cell
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			cell := buf.GetContent(x, y)
			if cell.Char == 0 || cell.Char == ' ' {
				continue
			}

			px := x * cellWidth
			py := (y + 1) * cellHeight

			// Build style classes
			var classes []string
			if cell.Style.Bold {
				classes = append(classes, "bold")
			}
			if cell.Style.Italic {
				classes = append(classes, "italic")
			}
			if cell.Style.Underline {
				classes = append(classes, "underline")
			}

			classAttr := ""
			if len(classes) > 0 {
				classAttr = fmt.Sprintf(` class="%s"`, strings.Join(classes, " "))
			}

			// Escape special XML characters
			text := escapeXML(string(cell.Char))

			sb.WriteString(fmt.Sprintf(`<text x="%d" y="%d"%s>%s</text>`,
				px, py, classAttr, text))
		}
	}

	sb.WriteString("\n</svg>")

	return os.WriteFile(filename, []byte(sb.String()), 0644)
}

// SaveToPNG saves the frame as a PNG image using bitmap font rendering.
// Note: This uses a simple custom PNG encoder without external dependencies.
func (e *Exporter) SaveToPNG(filename string) error {
	if e.frame == nil || e.frame.Buffer == nil {
		return fmt.Errorf("no frame to export")
	}

	buf := e.frame.Buffer
	width := buf.Width()
	height := buf.Height()

	// Cell dimensions (in pixels)
	cellWidth := 8
	cellHeight := 16

	// Create image buffer
	imgWidth := width * cellWidth
	imgHeight := height * cellHeight
	img := NewImageBuffer(imgWidth, imgHeight, e.colorScheme.Background)

	// Render each cell
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			cell := buf.GetContent(x, y)
			if cell.Char == 0 || cell.Char == ' ' {
				continue
			}

			// Determine color
			fgColor := e.colorScheme.Foreground
			if cell.Style.Bold {
				fgColor = e.colorScheme.Bold
			}

			// Render character using bitmap font
			renderCharToBitmap(img, x*cellWidth, y*cellHeight, cell.Char, fgColor, cell.Style)
		}
	}

	// Encode and save as PNG
	pngData, err := img.EncodePNG()
	if err != nil {
		return err
	}

	return os.WriteFile(filename, pngData, 0644)
}

// ToBase64PNG returns the frame as a base64-encoded PNG string.
// Useful for embedding in HTML or JSON.
func (e *Exporter) ToBase64PNG() (string, error) {
	if e.frame == nil || e.frame.Buffer == nil {
		return "", fmt.Errorf("no frame to export")
	}

	buf := e.frame.Buffer
	width := buf.Width()
	height := buf.Height()

	cellWidth := 8
	cellHeight := 16

	imgWidth := width * cellWidth
	imgHeight := height * cellHeight
	img := NewImageBuffer(imgWidth, imgHeight, e.colorScheme.Background)

	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			cell := buf.GetContent(x, y)
			if cell.Char == 0 || cell.Char == ' ' {
				continue
			}

			fgColor := e.colorScheme.Foreground
			if cell.Style.Bold {
				fgColor = e.colorScheme.Bold
			}

			renderCharToBitmap(img, x*cellWidth, y*cellHeight, cell.Char, fgColor, cell.Style)
		}
	}

	pngData, err := img.EncodePNG()
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(pngData), nil
}

// ToHTML returns the frame as an HTML fragment with embedded SVG.
func (e *Exporter) ToHTML() (string, error) {
	if e.frame == nil || e.frame.Buffer == nil {
		return "", fmt.Errorf("no frame to export")
	}

	buf := e.frame.Buffer
	width := buf.Width()
	height := buf.Height()

	cellWidth := 10
	cellHeight := 18

	svgWidth := width * cellWidth
	svgHeight := height * cellHeight

	var sb strings.Builder
	bg := e.colorScheme.Background
	fg := e.colorScheme.Foreground

	sb.WriteString(fmt.Sprintf(`<div style="background-color:#%02x%02x%02x;display:inline-block;padding:10px;border-radius:4px;">`, bg.R, bg.G, bg.B))
	sb.WriteString(fmt.Sprintf(`<svg xmlns="http://www.w3.org/2000/svg" width="%d" height="%d" viewBox="0 0 %d %d">`, svgWidth, svgHeight, svgWidth, svgHeight))
	sb.WriteString(fmt.Sprintf(`<style>.cell{font-family:monospace;font-size:%dpx;}</style>`, cellHeight-2))
	sb.WriteString(fmt.Sprintf(`<rect width="100%%" height="100%%" fill="#%02x%02x%02x"/>`, bg.R, bg.G, bg.B))

	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			cell := buf.GetContent(x, y)
			if cell.Char == 0 || cell.Char == ' ' {
				continue
			}

			px := x * cellWidth
			py := (y + 1) * cellHeight
			text := escapeHTML(string(cell.Char))

			sb.WriteString(fmt.Sprintf(`<text x="%d" y="%d" class="cell" fill="#%02x%02x%02x">%s</text>`,
				px, py, fg.R, fg.G, fg.B, text))
		}
	}

	sb.WriteString("</svg></div>")
	return sb.String(), nil
}

// escapeXML escapes special XML characters.
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	s = strings.ReplaceAll(s, "'", "&apos;")
	return s
}

// escapeHTML escapes special HTML characters.
func escapeHTML(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, "\"", "&quot;")
	return s
}

// ImageBuffer is a simple image buffer for PNG export.
type ImageBuffer struct {
	data [][]RGBA
	w, h int
}

// NewImageBuffer creates a new image buffer with the given dimensions and background color.
func NewImageBuffer(width, height int, bg RGBA) *ImageBuffer {
	img := &ImageBuffer{
		w:    width,
		h:    height,
		data: make([][]RGBA, height),
	}
	for y := range img.data {
		img.data[y] = make([]RGBA, width)
		for x := range img.data[y] {
			img.data[y][x] = bg
		}
	}
	return img
}

// SetPixel sets a pixel at the given coordinates.
func (img *ImageBuffer) SetPixel(x, y int, color RGBA) {
	if x >= 0 && x < img.w && y >= 0 && y < img.h {
		img.data[y][x] = color
	}
}

// Width returns the image width.
func (img *ImageBuffer) Width() int {
	return img.w
}

// Height returns the image height.
func (img *ImageBuffer) Height() int {
	return img.h
}

// EncodePNG encodes the image buffer as PNG.
// This is a simple PNG encoder for basic images.
func (img *ImageBuffer) EncodePNG() ([]byte, error) {
	return simplePNGEncode(img)
}

// renderCharToBitmap renders a single character to the image buffer.
func renderCharToBitmap(img *ImageBuffer, x, y int, char rune, color RGBA, style CellStyle) {
	// Get bitmap for character
	bitmap := getBitmapChar(char)
	if bitmap == nil {
		return
	}

	// Draw each pixel
	for row := 0; row < 16; row++ {
		for col := 0; col < 8; col++ {
			if row < len(bitmap) && col < 8 && (bitmap[row]>>(7-col))&1 == 1 {
				img.SetPixel(x+col, y+row, color)
			}
		}
	}

	// Draw underline if needed
	if style.Underline {
		for col := 0; col < 8; col++ {
			img.SetPixel(x+col, y+15, color)
		}
	}
}

// simplePNGEncode creates a simple PNG from an image buffer.
// This is a minimal PNG encoder that handles our specific use case.
func simplePNGEncode(img *ImageBuffer) ([]byte, error) {
	// For simplicity, we'll use a very basic uncompressed PNG format
	// PNG signature
	var buf bytes.Buffer
	buf.Write([]byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a})

	// IHDR chunk
	width := uint32(img.w)
	height := uint32(img.h)
	ihdr := make([]byte, 13)
	ihdr[0] = byte(width >> 24)
	ihdr[1] = byte(width >> 16)
	ihdr[2] = byte(width >> 8)
	ihdr[3] = byte(width)
	ihdr[4] = byte(height >> 24)
	ihdr[5] = byte(height >> 16)
	ihdr[6] = byte(height >> 8)
	ihdr[7] = byte(height)
	ihdr[8] = 8  // bit depth
	ihdr[9] = 6  // color type (RGBA)
	ihdr[10] = 0 // compression
	ihdr[11] = 0 // filter
	ihdr[12] = 0 // interlace

	writeChunk(&buf, "IHDR", ihdr)

	// IDAT chunk with image data
	rowBytes := img.w * 4
	rawData := make([]byte, (rowBytes+1)*img.h)

	for y := 0; y < img.h; y++ {
		offset := y * (rowBytes + 1)
		rawData[offset] = 0 // filter type
		for x := 0; x < img.w; x++ {
			pixel := img.data[y][x]
			px := offset + 1 + x*4
			rawData[px+0] = pixel.R
			rawData[px+1] = pixel.G
			rawData[px+2] = pixel.B
			rawData[px+3] = pixel.A
		}
	}

	// Simple compression (for now, just store the data as-is)
	// In a real implementation, you'd use zlib compression
	compressedData := deflateCompress(rawData)
	writeChunk(&buf, "IDAT", compressedData)

	// IEND chunk
	writeChunk(&buf, "IEND", []byte{})

	return buf.Bytes(), nil
}

// writeChunk writes a PNG chunk with correct CRC32 checksum.
func writeChunk(buf *bytes.Buffer, name string, data []byte) {
	// Write length
	length := uint32(len(data))
	buf.WriteByte(byte(length >> 24))
	buf.WriteByte(byte(length >> 16))
	buf.WriteByte(byte(length >> 8))
	buf.WriteByte(byte(length))

	// Write chunk name and data
	buf.WriteString(name)
	buf.Write(data)

	// Calculate and write CRC32
	// CRC is computed over the chunk type and data
	crcData := make([]byte, 4+len(data))
	copy(crcData, name)
	copy(crcData[4:], data)
	crc := crc32.ChecksumIEEE(crcData)
	buf.WriteByte(byte(crc >> 24))
	buf.WriteByte(byte(crc >> 16))
	buf.WriteByte(byte(crc >> 8))
	buf.WriteByte(byte(crc))
}

// deflateCompress compresses data using DEFLATE algorithm with zlib wrapper.
// This produces valid zlib compressed data for PNG IDAT chunks.
func deflateCompress(data []byte) []byte {
	var buf bytes.Buffer

	// Create flate writer with best compression
	writer, err := flate.NewWriter(&buf, flate.BestCompression)
	if err != nil {
		// Fallback to uncompressed if compression fails
		return data
	}

	// Write and close
	writer.Write(data)
	writer.Close()

	// Calculate Adler-32 checksum
	adler := adler32(data)

	// Build zlib header + compressed data + Adler-32
	result := make([]byte, 2, 2+len(buf.Bytes())+4)
	result[0] = 0x78 // CM=8 (DEFLATE), CINFO=7 (32K window)
	result[1] = 0xDA // FCHECK=26, FDICT=0, FLEVEL=2 (default)

	result = append(result, buf.Bytes()...)
	result = append(result,
		byte(adler>>24),
		byte(adler>>16),
		byte(adler>>8),
		byte(adler),
	)

	return result
}

// adler32 calculates the Adler-32 checksum of data.
// This is required for the zlib trailer in PNG.
func adler32(data []byte) uint32 {
	const mod = 65521
	a := uint32(1) // initial value
	b := uint32(0)

	// Process data in 3800-byte chunks (optimized for mod operation)
	for len(data) >= 3800 {
		for i := 0; i < 3800; i++ {
			a += uint32(data[i])
			b += a
		}
		a %= mod
		b %= mod
		data = data[3800:]
	}

	// Process remaining bytes
	for _, v := range data {
		a += uint32(v)
		b += a
	}
	a %= mod
	b %= mod

	return (b << 16) | a
}

// getBitmapChar returns an 8x16 bitmap for the given character.
// This bitmap font covers ASCII characters and common box drawing characters.
func getBitmapChar(char rune) []byte {
	// Check for box drawing characters first
	if boxChar, ok := boxDrawingBitmaps[char]; ok {
		return boxChar
	}

	// Check ASCII range
	if char < 32 || char > 126 {
		// Return a placeholder for non-ASCII
		if char == '\n' || char == '\t' {
			return nil
		}
		return questionBitmap
	}

	// Bitmap font data (8x16 pixels per character)
	// Each byte represents one row, most significant bit is leftmost pixel
	bitmapFont := map[rune][]byte{
		' ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'!': {0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
		'"': {0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'#': {0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00},
		'$': {0x00, 0x10, 0x10, 0x7C, 0xD6, 0xD0, 0x7C, 0x16, 0xD6, 0xDC, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00},
		'%': {0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'&': {0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
		'\'': {0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'(': {0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00},
		')': {0x00, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00},
		'*': {0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x38, 0xFE, 0x38, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'+': {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		',': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00},
		'-': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'.': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'/': {0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00},
		'0': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'1': {0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00},
		'2': {0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
		'3': {0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'4': {0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00},
		'5': {0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'6': {0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'7': {0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00},
		'8': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'9': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00},
		':': {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
		';': {0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
		'<': {0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00},
		'=': {0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'>': {0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},
		'?': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
		'@': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'A': {0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'B': {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00},
		'C': {0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'D': {0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00},
		'E': {0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00},
		'F': {0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
		'G': {0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00},
		'H': {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'I': {0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'J': {0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00},
		'K': {0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
		'L': {0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00},
		'M': {0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'N': {0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'O': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'P': {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
		'Q': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00},
		'R': {0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
		'S': {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'T': {0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'U': {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'V': {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00},
		'W': {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00},
		'X': {0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'Y': {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'Z': {0x00, 0x00, 0xFE, 0xC6, 0x8C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
		'[': {0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'\\': {0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00},
		']': {0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'^': {0x00, 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'_': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00},
		'`': {0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		'a': {0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
		'b': {0x00, 0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'c': {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'd': {0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
		'e': {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'f': {0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
		'g': {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00},
		'h': {0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
		'i': {0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'j': {0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00},
		'k': {0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00},
		'l': {0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00},
		'm': {0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'n': {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00},
		'o': {0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		'p': {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00},
		'q': {0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00},
		'r': {0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00},
		's': {0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00},
		't': {0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00},
		'u': {0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00},
		'v': {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00},
		'w': {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00},
		'x': {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},
		'y': {0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00},
		'z': {0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00},
		'{': {0x00, 0x00, 0x00, 0x00, 0x38, 0x60, 0x60, 0xC0, 0x60, 0x60, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00},
		'|': {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},
		'}': {0x00, 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x06, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00},
		'~': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	}

	if bitmap, ok := bitmapFont[char]; ok {
		return bitmap
	}

	// Return question mark for unknown characters
	return questionBitmap
}

// Bitmap for question mark (fallback)
var questionBitmap = []byte{
	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
}

// boxDrawingBitmaps contains 8x16 bitmaps for box drawing characters.
// Each row is represented as 2 bytes (16 bits) for proper horizontal lines.
var boxDrawingBitmaps = map[rune][]byte{
	// Horizontal lines
	'‚îÄ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ïê': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îÅ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ä£': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ä¢': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00},

	// Vertical lines
	'‚îÇ': {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
	'‚ïë': {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},
	'‚îÉ': {0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24},

	// Corners
	'‚îå': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚îê': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚îî': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00},
	'‚îò': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îç': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚îé': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚îè': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚îë': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚îí': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚îì': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚îï': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îñ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00},
	'‚îó': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îô': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îö': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îõ': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îú': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚î§': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚î•': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚î¨': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚î≠': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚îÆ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚îØ': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚î∞': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚î¥': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îµ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00},
	'‚î∂': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚î∑': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚î∏': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îπ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚î∫': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îª': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚îº': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïÄ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïÅ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚ïÇ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïÉ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ïÑ': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïÖ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïÜ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïá': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚ïà': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïâ': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ïä': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïã': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïå': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïç': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0x18, 0x18, 0x18, 0x18},
	'‚ïé': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x18, 0x18, 0x18, 0x18},
	'‚ïè': {0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x18, 0x18, 0x18},

	// Double line box drawing
	'‚ïî': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ïó': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ïö': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ïù': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ï†': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ï£': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ï¶': {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},
	'‚ï©': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},
	'‚ï¨': {0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C},

	// Common emoji and symbols (simplified)
	'üë§': {0x00, 0x3C, 0x42, 0x99, 0xA5, 0xA5, 0x99, 0x42, 0x3C, 0x00, 0x24, 0x66, 0x66, 0x24, 0x00, 0x00},
	'üíé': {0x00, 0x18, 0x3C, 0x7E, 0xDB, 0xE7, 0xE7, 0xDB, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
	'‚úì': {0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x8F, 0xDC, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x00},
	'‚úó': {0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0x70, 0x38, 0x38, 0x70, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00},
}
